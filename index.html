<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Atlasphere - Your Travel Tracker</title>

    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://unpkg.com/topojson@3"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

    <style>
        /* --- Obsidian Observatory Theme Variables --- */
        :root {
            --bg-primary: #0b0e12;
            --bg-secondary: #121826;
            --bg-tertiary: #1a2233;
            --glass-surface: rgba(18, 24, 38, 0.6);
            --glass-strong: rgba(18, 24, 38, 0.78);
            --glass-border: rgba(232, 238, 248, 0.14);
            --glass-highlight: rgba(255, 255, 255, 0.16);
            --accent-primary: #6fe3ff;
            --accent-secondary: #e6c48f;
            --accent-tertiary: #e8eef8;
            --text-primary: #e9f0fb;
            --text-secondary: #a7b3c9;
            --border-color: rgba(111, 227, 255, 0.25);
            --border-color-medium: rgba(230, 196, 143, 0.3);
            --glow-color-light: rgba(111, 227, 255, 0.18);
            --danger-color: #ff6b6b;
            --danger-hover-bg: rgba(255, 107, 107, 0.12);
            --font-main: 'SF Pro Text', 'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            --font-display: 'SF Pro Display', 'SF Pro Text', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            --shadow-soft: 0 30px 80px rgba(5, 8, 14, 0.55);
            --shadow-card: 0 18px 60px rgba(5, 8, 14, 0.4);
            /* Globe Colors (Obsidian Theme) */
            --globe-ocean: #0a0f18;
            --globe-land: #1d2536;
            --globe-land-outline: #2b344a;
            --globe-visited-outline: var(--accent-secondary);
            --flag-fallback-fill: var(--accent-primary);
            --flag-error-fill: #3b404d;
        }

        /* --- Base HTML & Body Styles --- */
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            overscroll-behavior: none; /* Prevent pull-to-refresh */
        }

        body {
            font-family: var(--font-main);
            background: radial-gradient(circle at 20% 10%, rgba(111, 227, 255, 0.16), transparent 45%),
                        radial-gradient(circle at 80% 0%, rgba(230, 196, 143, 0.12), transparent 40%),
                        linear-gradient(180deg, #111622 0%, #0b0e12 100%);
            color: var(--text-primary);
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            align-items: center;
            padding: 1rem; /* Base padding */
            position: relative;
            overflow-x: hidden;
        }

        body::before {
            content: '';
            position: absolute;
            inset: -10% -10% auto -10%;
            height: 55%;
            background: radial-gradient(circle at 30% 30%, rgba(111, 227, 255, 0.18), transparent 55%),
                        radial-gradient(circle at 70% 10%, rgba(230, 196, 143, 0.16), transparent 50%);
            filter: blur(30px);
            opacity: 0.9;
            z-index: 0;
            pointer-events: none;
        }

        body::after {
            content: '';
            position: absolute;
            inset: 0;
            background-image: radial-gradient(circle at 1px 1px, rgba(255, 255, 255, 0.035) 1px, transparent 0);
            background-size: 4px 4px;
            opacity: 0.35;
            z-index: 0;
            pointer-events: none;
        }

        /* --- Typography & Title --- */
        h1#main-title {
            font-weight: 600;
            letter-spacing: 1px;
            color: var(--text-primary);
            margin-bottom: 0.5rem;
            padding-bottom: 8px;
            position: relative;
            display: inline-block;
            text-align: center;
            font-size: 2.4rem;
            font-family: var(--font-display);
            text-shadow: 0 12px 28px rgba(15, 20, 30, 0.65);
            position: relative;
            z-index: 1;
        }
        @media (min-width: 768px) {
            h1#main-title {
                font-size: 3.2rem;
                margin-top: 1.5rem;
                margin-bottom: 2rem;
            }
        }
        h1#main-title::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 90px;
            height: 3px;
            background: linear-gradient(90deg, rgba(111, 227, 255, 0.8) 0%, rgba(230, 196, 143, 0.9) 100%);
            border-radius: 999px;
            box-shadow: 0 0 18px rgba(111, 227, 255, 0.35);
        }

        p#subtitle {
            text-align: center;
            margin-bottom: 1.5rem;
            font-size: 1.08rem;
            color: var(--text-secondary);
            font-weight: 400;
            line-height: 1.7;
            max-width: 90%;
            text-shadow: 0 8px 18px rgba(10, 14, 20, 0.45);
            position: relative;
            z-index: 1;
        }
        @media (min-width: 768px) {
            p#subtitle {
                font-size: 1.18rem;
                margin-bottom: 2.5rem;
                max-width: 100%;
            }
        }

        .info-label {
            font-size: 1rem;
            color: var(--text-secondary);
            font-weight: 500;
        }

        .glass-panel {
            background: var(--glass-surface);
            border: 1px solid var(--glass-border);
            border-radius: 18px;
            backdrop-filter: blur(18px);
            -webkit-backdrop-filter: blur(18px);
            box-shadow: var(--shadow-card);
            position: relative;
            overflow: hidden;
            isolation: isolate;
        }
        .glass-panel::before {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.12), transparent 45%);
            opacity: 0.6;
            z-index: 0;
            pointer-events: none;
        }
        .glass-panel > * {
            position: relative;
            z-index: 1;
        }
        .glass-outline {
            box-shadow: 0 0 0 1px rgba(230, 196, 143, 0.22), 0 14px 30px rgba(5, 8, 14, 0.35);
        }
        .enter-reveal {
            animation: riseIn 0.8s ease both;
            animation-delay: var(--enter-delay, 0s);
        }

        @keyframes riseIn {
            0% { opacity: 0; transform: translateY(18px); }
            100% { opacity: 1; transform: translateY(0); }
        }

        /* --- Percentile Banner --- */
        #percentile-banner {
            width: 100%;
            max-width: 1200px;
            margin: 0.35rem auto 1.4rem auto;
            padding: 1.1rem 1.4rem 1.2rem;
            border-radius: 20px;
            border: 1px solid rgba(230, 196, 143, 0.35);
            background: linear-gradient(120deg, rgba(18, 24, 38, 0.9) 0%, rgba(12, 16, 26, 0.85) 100%);
            text-align: center;
            box-shadow: 0 22px 60px rgba(6, 10, 18, 0.55);
            position: relative;
            z-index: 1;
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 0.35rem;
            min-height: 88px;
        }
        #percentile-message {
            font-size: 1.2rem;
            font-weight: 600;
            letter-spacing: 0.3px;
            color: var(--accent-secondary);
            text-shadow: 0 10px 24px rgba(230, 196, 143, 0.3);
            font-family: var(--font-display);
            line-height: 1.3;
        }
        #percentile-subnote {
            margin-top: 0.4rem;
            font-size: 0.82rem;
            color: var(--text-secondary);
            opacity: 0.8;
            line-height: 1.4;
        }
        @media (min-width: 768px) {
            #percentile-message {
                font-size: 1.55rem;
            }
        }

        /* --- View Container --- */
        #app-container {
            width: 100%;
            max-width: 1500px; /* Max width for content */
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
            z-index: 1;
        }

        /* --- Navigation Tabs --- */
        #view-tabs {
            margin-bottom: 1.5rem;
            display: flex;
            gap: 0.5rem;
            background: var(--glass-surface);
            padding: 0.45rem;
            border-radius: 14px;
            border: 1px solid var(--glass-border);
            box-shadow: var(--shadow-card);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            flex-wrap: wrap;
            justify-content: space-between;
            align-items: center;
            position: relative;
            z-index: 1;
            overflow: visible;
        }
        .tab-group {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }
        .tab-button {
            padding: 0.55rem 1.3rem;
            border: 1px solid transparent;
            background: transparent;
            color: var(--text-secondary);
            border-radius: 7px;
            cursor: pointer;
            transition: all 0.22s cubic-bezier(.4,0,.2,1);
            font-weight: 600;
            letter-spacing: 0.4px;
            white-space: nowrap;
            font-size: 1rem;
        }
        .tab-button:hover {
            color: var(--accent-primary);
            background: rgba(111, 227, 255, 0.08);
            border-color: rgba(111, 227, 255, 0.45);
            box-shadow: 0 0 0 1px rgba(111, 227, 255, 0.18);
        }
        .tab-button.active {
            background: linear-gradient(120deg, rgba(111, 227, 255, 0.25) 0%, rgba(230, 196, 143, 0.22) 100%);
            color: var(--text-primary);
            border-color: rgba(230, 196, 143, 0.5);
            font-weight: 700;
            box-shadow: 0 10px 22px rgba(9, 12, 18, 0.45);
            text-shadow: none;
        }
        .tab-button:disabled {
            opacity: 0.55;
            cursor: not-allowed;
            box-shadow: none;
        }
        #reset-button {
            border-color: rgba(232, 238, 248, 0.12);
            color: var(--text-secondary);
        }
        #reset-button:hover:not(:disabled) {
            border-color: var(--danger-color);
            color: var(--danger-color);
            background: var(--danger-hover-bg);
            box-shadow: none;
        }
        @media (max-width: 720px) {
            #view-tabs {
                justify-content: center;
            }
            #reset-button {
                width: 100%;
            }
        }

        /* --- View Panels --- */
        .view-panel {
            width: 100%;
            display: none; /* Hidden by default */
            flex-direction: column;
            align-items: center;
        }
        .view-panel.active {
            display: flex; /* Shown when active */
        }

        /* --- Map View Specific Styles --- */
        #map-container {
            width: 100%;
            margin: 0 auto 1.5rem auto;
            aspect-ratio: 16 / 9;
            max-height: calc(70vh - 100px);
            position: relative;
            overflow: hidden;
            border: 1px solid var(--glass-border);
            border-radius: 22px;
            cursor: grab;
            background: linear-gradient(120deg, rgba(18, 24, 38, 0.8) 0%, rgba(10, 14, 22, 0.92) 100%);
            box-shadow: var(--shadow-soft);
        }
        #map-container:active { cursor: grabbing; }

        #world-map {
            display: block;
            width: 100%;
            height: 100%;
            background-color: transparent;
        }
        .country {
            fill: rgba(30, 38, 56, 0.92);
            stroke: rgba(10, 14, 22, 0.8);
            stroke-width: 0.7;
            cursor: pointer;
            transition: fill 0.18s, transform 0.1s, stroke 0.18s, opacity 0.18s;
            transform-origin: center center;
            opacity: 1;
        }
        .country:hover:not(.visited) {
            fill: rgba(111, 227, 255, 0.65);
            stroke: rgba(230, 196, 143, 0.65);
            opacity: 0.93;
            filter: drop-shadow(0 0 10px rgba(111, 227, 255, 0.35));
        }
        .country.pressed:not(.visited) {
            fill: var(--accent-secondary);
            filter: brightness(0.97);
            transform: scale(0.995);
        }
        .country.visited {
            stroke: var(--accent-secondary);
            stroke-width: 1.05;
            filter: drop-shadow(0 0 8px rgba(230, 196, 143, 0.4));
            box-shadow: none;
            animation: none;
            transform: scale(1);
        }
        .country.visited:hover {
            stroke: var(--accent-primary);
            filter: brightness(1.08) drop-shadow(0 0 10px rgba(111, 227, 255, 0.45));
            box-shadow: none;
            opacity: 0.85;
        }
        .country.flag-error {
           fill: var(--flag-error-fill);
           stroke: #777;
        }

        .flag-pattern image {
            width: 100%;
            height: 100%;
            preserveAspectRatio: xMidYMid slice;
        }

        #tooltip {
            position: absolute;
            display: none;
            background: rgba(12, 16, 26, 0.88);
            color: var(--accent-tertiary);
            border: 1px solid rgba(111, 227, 255, 0.45);
            padding: 0.6rem 1rem;
            border-radius: 10px;
            font-family: var(--font-main);
            font-size: 0.92rem;
            font-weight: 500;
            white-space: nowrap;
            z-index: 100;
            pointer-events: none;
            box-shadow: 0 10px 22px rgba(6, 10, 18, 0.45);
            backdrop-filter: blur(10px);
            transition: opacity 0.15s;
        }

        /* --- Globe View Specific Styles --- */
        #globe-view {
            height: 70vh;
            max-height: 600px;
            min-height: 300px;
            position: relative;
            width: 100%;
        }
        #globe-container {
            width: 100%;
            height: 100%;
            border-radius: 22px;
            overflow: hidden;
            position: relative;
            border: 1px solid var(--glass-border);
            background: linear-gradient(120deg, rgba(18, 24, 38, 0.8) 0%, rgba(10, 14, 22, 0.92) 100%);
            cursor: grab;
            box-shadow: var(--shadow-soft);
        }
        #globe-container:active { cursor: grabbing; }

        #globe-canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        #globe-loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: var(--accent-secondary);
            font-size: 1.2rem;
            display: none;
            z-index: 10;
            text-align: center;
            background: rgba(8, 10, 16, 0.7);
            padding: 1.2rem;
            border-radius: 12px;
            box-shadow: 0 14px 30px rgba(6, 10, 18, 0.5);
        }

        /* --- Shared Visited Info Styles --- */
        #visited-info {
            margin-top: 1.5rem;
            padding: 1.5rem 1rem;
            text-align: center;
            width: 100%;
            max-width: 900px;
            background: var(--glass-strong);
            border-radius: 20px;
            border: 1px solid var(--glass-border);
            position: relative;
            box-shadow: var(--shadow-card);
        }
        #stats-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 0.85rem;
            margin-top: 1.1rem;
        }
        .stat-card {
            background: rgba(10, 14, 22, 0.8);
            border: 1px solid rgba(232, 238, 248, 0.1);
            border-radius: 16px;
            padding: 0.85rem 0.9rem;
            text-align: center;
            box-shadow: inset 0 1px 8px rgba(6, 10, 18, 0.5);
        }
        .stat-label {
            display: block;
            font-size: 0.78rem;
            letter-spacing: 0.18em;
            text-transform: uppercase;
            color: var(--text-secondary);
            font-weight: 600;
            margin-bottom: 0.35rem;
        }
        .stat-value {
            font-size: 2rem;
            font-weight: 700;
            color: var(--accent-primary);
            line-height: 1;
            text-shadow: 0 10px 22px rgba(111, 227, 255, 0.35);
        }
        #countries-left {
            color: var(--accent-secondary);
            text-shadow: 0 10px 22px rgba(230, 196, 143, 0.35);
        }
        #countries-total {
            color: var(--text-secondary);
            text-shadow: none;
            font-weight: 600;
        }
        #visited-info-label {
            color: var(--accent-secondary);
        }
        #progress-container {
            width: 100%;
            background: rgba(18, 24, 38, 0.7);
            border-radius: 999px;
            height: 1.5rem;
            overflow: hidden;
            margin-bottom: 1.5rem;
            border: 1px solid rgba(232, 238, 248, 0.12);
            box-shadow: inset 0 1px 4px rgba(7, 10, 16, 0.6);
        }
        #progress-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, rgba(111, 227, 255, 0.85) 0%, rgba(230, 196, 143, 0.95) 100%);
            border-radius: 999px;
            transition: width 0.5s cubic-bezier(.4,0,.2,1);
            display: flex;
            align-items: center;
            justify-content: flex-end;
            font-size: 0.9rem;
            font-weight: 700;
            color: #fff;
            text-shadow: 0 1px 10px rgba(12, 16, 26, 0.65);
            padding-right: 8px;
            overflow: hidden;
        }
        #visited-list-container {
            margin-top: 1.5rem;
            padding: 1.2rem 1rem;
            background: rgba(10, 14, 22, 0.8);
            border-radius: 14px;
            border: 1px solid rgba(232, 238, 248, 0.1);
        }
        .list-title {
            font-size: 1.08rem;
            color: var(--accent-secondary);
            margin-bottom: 1rem;
            font-weight: 700;
            text-align: left;
            letter-spacing: 0.3px;
            border-bottom: 1px solid rgba(232, 238, 248, 0.08);
            padding-bottom: 0.5rem;
        }
        #visited-list { text-align: left; }

        .continent-group { margin-bottom: 1rem; }

        .continent-title {
            font-weight: 800;
            color: var(--accent-secondary);
            margin-bottom: 0.6rem;
            font-size: 0.92rem;
            letter-spacing: 0.6px;
            text-transform: uppercase;
        }
        #visited-list ul {
            list-style: none;
            padding: 0;
            margin: 0;
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            align-items: flex-start;
        }
        #visited-list li {
            background: rgba(18, 24, 38, 0.7);
            color: var(--text-secondary);
            padding: 0.38rem 1rem;
            border-radius: 999px;
            font-size: 0.88rem;
            font-weight: 500;
            border: 1px solid rgba(232, 238, 248, 0.08);
            transition: all 0.18s;
            cursor: default;
        }
        #visited-list li:hover {
            border-color: rgba(111, 227, 255, 0.4);
            background: rgba(18, 24, 38, 0.9);
            color: var(--accent-primary);
        }

        /* --- Search Panel --- */
        #explore-controls {
            width: 100%;
            max-width: 900px;
            margin: 0.5rem auto 1.5rem auto;
        }
        #search-panel {
            background: var(--glass-strong);
            border-radius: 20px;
            border: 1px solid var(--glass-border);
            padding: 1.2rem 1rem;
            box-shadow: var(--shadow-card);
        }
        #search-label {
            display: block;
            font-size: 0.9rem;
            letter-spacing: 0.12em;
            text-transform: uppercase;
            color: rgba(232, 238, 248, 0.7);
            font-weight: 600;
            margin-bottom: 0.6rem;
        }
        .search-input-row {
            display: flex;
            flex-wrap: wrap;
            gap: 0.6rem;
            align-items: center;
        }
        #country-search {
            flex: 1 1 260px;
            padding: 0.7rem 0.9rem;
            border-radius: 12px;
            border: 1px solid rgba(232, 238, 248, 0.12);
            background: rgba(10, 14, 22, 0.8);
            color: var(--text-primary);
            font-size: 1rem;
            font-family: var(--font-main);
            box-shadow: inset 0 1px 6px rgba(6, 10, 18, 0.6);
            caret-color: var(--accent-primary);
        }
        #country-search:focus {
            outline: none;
            border-color: rgba(111, 227, 255, 0.55);
            box-shadow: 0 0 16px rgba(111, 227, 255, 0.2);
        }
        #country-search::placeholder {
            color: rgba(232, 238, 248, 0.45);
        }
        #clear-search {
            padding: 0.65rem 1rem;
            border: 1px solid rgba(232, 238, 248, 0.12);
            border-radius: 12px;
            background: rgba(18, 24, 38, 0.75);
            color: var(--text-secondary);
            font-weight: 700;
            cursor: pointer;
            transition: all 0.18s cubic-bezier(.4,0,.2,1);
        }
        #clear-search:hover {
            border-color: rgba(111, 227, 255, 0.4);
            color: var(--accent-primary);
            background: rgba(18, 24, 38, 0.9);
        }
        #search-hint {
            margin-top: 0.6rem;
            font-size: 0.85rem;
            color: var(--text-secondary);
            opacity: 0.8;
        }
        #search-results {
            margin: 0.75rem 0 0 0;
            padding: 0;
            list-style: none;
            display: grid;
            gap: 0.5rem;
            max-height: 240px;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: rgba(111, 227, 255, 0.35) transparent;
        }
        #search-results::-webkit-scrollbar {
            width: 6px;
        }
        #search-results::-webkit-scrollbar-track {
            background: transparent;
        }
        #search-results::-webkit-scrollbar-thumb {
            background: rgba(111, 227, 255, 0.25);
            border-radius: 999px;
        }
        .search-result {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 0.75rem;
            padding: 0.55rem 0.85rem;
            border-radius: 14px;
            border: 1px solid rgba(232, 238, 248, 0.08);
            background: rgba(18, 24, 38, 0.7);
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.18s cubic-bezier(.4,0,.2,1);
        }
        .search-result:hover {
            border-color: rgba(111, 227, 255, 0.4);
            color: var(--accent-primary);
            background: rgba(18, 24, 38, 0.9);
        }
        .search-result.active {
            border-color: rgba(230, 196, 143, 0.55);
            color: var(--accent-secondary);
            box-shadow: 0 10px 24px rgba(6, 10, 18, 0.4);
        }
        .search-result.visited {
            border-color: rgba(230, 196, 143, 0.35);
            color: var(--accent-secondary);
        }
        .search-meta {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.14em;
            color: rgba(232, 238, 248, 0.55);
        }

        /* --- Action Buttons Container --- */
        #action-buttons-container {
            margin-top: 1.5rem;
            margin-bottom: 2rem;
            display: flex;
            flex-direction: column;
            gap: 0.85rem;
            width: 100%;
            max-width: 900px;
            align-items: center;
            padding: 1rem;
            background: var(--glass-surface);
            border: 1px solid var(--glass-border);
            border-radius: 20px;
            box-shadow: var(--shadow-card);
            overflow: visible;
        }
        @media (min-width: 640px) {
            #action-buttons-container {
                flex-direction: row;
                justify-content: center;
                gap: 1.2rem;
                flex-wrap: wrap;
            }
        }

        /* --- Action Button Styles (Luxury Theme) --- */
        .action-button {
            padding: 0.7rem 1.5rem;
            border: 1px solid rgba(232, 238, 248, 0.14);
            background: rgba(18, 24, 38, 0.7);
            color: var(--text-secondary);
            border-radius: 14px;
            cursor: pointer;
            transition: all 0.22s cubic-bezier(.4,0,.2,1);
            font-weight: 700;
            letter-spacing: 0.4px;
            width: 80%;
            max-width: 260px;
            text-align: center;
            font-size: 1rem;
            box-shadow: 0 14px 30px rgba(6, 10, 18, 0.45);
            line-height: 1.5;
        }
        @media (min-width: 640px) {
            .action-button {
                width: auto;
                flex-grow: 1;
            }
        }

        .action-button:hover {
            border-color: rgba(111, 227, 255, 0.45);
            color: var(--accent-primary);
            background: rgba(18, 24, 38, 0.9);
            box-shadow: 0 18px 36px rgba(6, 10, 18, 0.55);
        }
        #download-summary-button {
            border-color: rgba(111, 227, 255, 0.5);
            color: var(--accent-primary);
            background: rgba(8, 12, 20, 0.65);
        }
        #download-summary-button:hover:not(:disabled) {
            background: rgba(111, 227, 255, 0.12);
            color: var(--accent-secondary);
            border-color: rgba(230, 196, 143, 0.6);
            box-shadow: 0 0 16px rgba(230, 196, 143, 0.25);
        }
        .action-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            box-shadow: none;
            background: rgba(12, 16, 24, 0.4) !important;
            border-color: rgba(232, 238, 248, 0.08) !important;
            color: rgba(232, 238, 248, 0.4) !important;
        }

        /* --- Summary Export Canvas --- */
        .summary-export {
            position: fixed;
            left: -10000px;
            top: 0;
            width: 1200px;
            padding: 2.5rem 2.5rem 2.2rem;
            background: #0b0e12;
            color: var(--text-primary);
            font-family: var(--font-main);
            border-radius: 24px;
            border: 1px solid rgba(232, 238, 248, 0.08);
            box-shadow: none;
        }
        .summary-export__header {
            text-align: center;
            margin-bottom: 1.6rem;
        }
        .summary-export__title {
            font-size: 2.2rem;
            font-weight: 700;
            letter-spacing: 0.3px;
            margin-bottom: 0.35rem;
            color: var(--text-primary);
        }
        .summary-export__tagline {
            font-size: 1.15rem;
            font-weight: 600;
            color: var(--accent-secondary);
        }
        .summary-export__map {
            border-radius: 22px;
            background: #101624;
            border: 1px solid rgba(232, 238, 248, 0.08);
            overflow: hidden;
            padding: 0.6rem;
        }
        .summary-export__map svg {
            width: 100%;
            height: auto;
            display: block;
        }
        .summary-export__footer {
            margin-top: 1.6rem;
        }
        .summary-export__stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
            gap: 0.85rem;
            margin-bottom: 1.2rem;
        }
        .summary-export .stat-card {
            background: #111827;
            border: 1px solid rgba(232, 238, 248, 0.08);
            box-shadow: none;
        }
        .summary-export__list {
            background: #111827;
            border: 1px solid rgba(232, 238, 248, 0.08);
            border-radius: 16px;
            padding: 1rem;
            text-align: left;
        }
        /* --- Motion --- */
        @keyframes countPulse {
            0% { transform: scale(1); }
            35% { transform: scale(1.08); }
            100% { transform: scale(1); }
        }
        .count-pulse {
            animation: countPulse 0.35s ease-out;
        }
        @keyframes visitPulse {
            0% { filter: drop-shadow(0 0 0 rgba(230, 196, 143, 0)); }
            50% { filter: drop-shadow(0 0 12px rgba(230, 196, 143, 0.5)); }
            100% { filter: drop-shadow(0 0 0 rgba(230, 196, 143, 0)); }
        }
        .visit-animate {
            animation: visitPulse 0.6s ease-out;
        }

        /* --- Name Prompt Dialog Styles --- */
        #name-prompt-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(6, 8, 12, 0.82);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(7px);
            padding: 1rem;
        }
        #name-prompt-dialog {
            background: rgba(18, 24, 38, 0.85);
            padding: 2rem 1.5rem;
            border-radius: 18px;
            border: 1px solid rgba(232, 238, 248, 0.16);
            box-shadow: 0 30px 70px rgba(6, 10, 18, 0.6);
            text-align: center;
            max-width: 400px;
            width: 95%;
            backdrop-filter: blur(18px);
            -webkit-backdrop-filter: blur(18px);
        }
        #name-prompt-dialog h2 {
            color: var(--accent-secondary);
            font-weight: 700;
            margin-top: 0;
            margin-bottom: 1.2rem;
            font-size: 1.35rem;
            text-shadow: 0 10px 24px rgba(230, 196, 143, 0.35);
            font-family: var(--font-display);
        }
        #name-prompt-dialog p {
            color: var(--text-secondary);
            margin-bottom: 1.5rem;
            font-size: 1rem;
        }
        #name-input {
            width: 100%;
            padding: 0.85rem 1.1rem;
            margin-bottom: 1.5rem;
            border-radius: 12px;
            border: 1px solid rgba(232, 238, 248, 0.12);
            background: rgba(10, 14, 22, 0.85);
            color: var(--text-primary);
            font-family: var(--font-main);
            font-size: 1.05rem;
            box-shadow: inset 0 1px 6px rgba(6, 10, 18, 0.6);
            transition: border-color 0.2s;
        }
        #name-input:focus {
            outline: none;
            border-color: rgba(111, 227, 255, 0.5);
            box-shadow: 0 0 16px rgba(111, 227, 255, 0.25);
        }
        #name-input::placeholder {
            color: rgba(232, 238, 248, 0.45);
        }
        #name-prompt-button {
            padding: 0.7rem 2rem;
            border: 1px solid rgba(111, 227, 255, 0.6);
            background: linear-gradient(120deg, rgba(111, 227, 255, 0.35) 0%, rgba(230, 196, 143, 0.3) 100%);
            color: var(--text-primary);
            border-radius: 14px;
            cursor: pointer;
            transition: all 0.22s cubic-bezier(.4,0,.2,1);
            font-weight: 800;
            font-size: 1.05rem;
            letter-spacing: 0.5px;
            width: 100%;
        }
        #name-prompt-button:hover {
            background: rgba(230, 196, 143, 0.5);
            border-color: rgba(230, 196, 143, 0.8);
            color: #10141d;
            box-shadow: 0 0 18px rgba(230, 196, 143, 0.4);
        }

        /* Utility class to hide elements visually but keep accessible */
        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border-width: 0;
        }

        /* Utility class for hidden elements */
        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <h1 id="main-title">Atlasphere</h1>

    <p id="subtitle">Loading your exploration data...</p>

    <div id="percentile-banner" class="glass-panel enter-reveal hidden" style="--enter-delay: 0.05s;" aria-live="polite">
        <div id="percentile-message"></div>
        <div id="percentile-subnote">Estimated from global travel patterns. Not an official statistic.</div>
    </div>

    <div id="view-tabs" class="glass-panel enter-reveal" style="--enter-delay: 0.1s;">
        <div class="tab-group">
            <button class="tab-button active" data-view="map-view">World Map</button>
            <button class="tab-button" data-view="globe-view">3D Globe</button>
        </div>
        <button id="reset-button" class="tab-button" type="button" disabled>Reset Map</button>
    </div>

    <div id="app-container">

        <div id="map-view" class="view-panel active">
            <div id="map-container" class="glass-panel enter-reveal" style="--enter-delay: 0.15s;" aria-label="Interactive world map">
                <svg id="world-map" viewBox="0 0 960 500" preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" role="img" aria-labelledby="mapTitle">
                    <title id="mapTitle">World Map - Click countries to mark as visited</title>
                    <defs id="flag-patterns">
                        </defs>
                    <g id="map-group"></g> </svg>
            </div>
            <div id="tooltip" role="tooltip"></div> </div>

        <div id="globe-view" class="view-panel">
            <div id="globe-container" class="glass-panel enter-reveal" style="--enter-delay: 0.15s;" aria-label="Interactive 3D globe - Click countries to mark visited">
                 <canvas id="globe-canvas"></canvas>
                 <div id="globe-loading" aria-live="polite">Initializing 3D Globe...</div>
            </div>
        </div>

        <div id="explore-controls">
            <div id="search-panel" class="glass-panel enter-reveal" style="--enter-delay: 0.2s;">
                <label id="search-label" for="country-search">Find a Country</label>
                <div class="search-input-row">
                    <input type="text" id="country-search" placeholder="Type a country name..." autocomplete="off">
                    <button id="clear-search" type="button">Clear</button>
                </div>
                <div id="search-hint">Use Up/Down + Enter to select. Click to toggle visited status.</div>
                <ul id="search-results" role="listbox" aria-label="Country search results"></ul>
            </div>
        </div>

        <div id="visited-info" class="glass-panel enter-reveal" style="--enter-delay: 0.25s;" aria-live="polite">
             <div id="progress-container" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0" title="Percentage of world countries visited">
                 <div id="progress-bar">0%</div>
             </div>
             <div id="stats-row">
                 <div class="stat-card">
                     <span id="visited-info-label" class="stat-label">Countries Visited:</span>
                     <div id="visited-count" class="stat-value">0</div>
                 </div>
                 <div class="stat-card">
                     <span class="stat-label">Countries Left:</span>
                     <div id="countries-left" class="stat-value">0</div>
                 </div>
                 <div class="stat-card">
                     <span class="stat-label">Total Countries:</span>
                     <div id="countries-total" class="stat-value">0</div>
                 </div>
             </div>
             <div id="visited-list-container" class="hidden">
                 <h3 class="list-title">Visited Countries by Continent:</h3>
                 <div id="visited-list">
                     </div>
             </div>
        </div>

        <div id="action-buttons-container" class="glass-panel enter-reveal" style="--enter-delay: 0.3s;">
            <button id="export-button" class="action-button">Export Data</button>
            <button id="import-button" class="action-button">Import Data</button>
            <input type="file" id="import-file" class="hidden" accept="application/json,.json">
            <button id="download-summary-button" class="action-button" disabled>Download Summary</button>
        </div>

    </div> <div id="name-prompt-overlay" role="dialog" aria-modal="true" aria-labelledby="name-prompt-title">
        <div id="name-prompt-dialog">
            <h2 id="name-prompt-title">Welcome Explorer!</h2>
            <p>Please enter your name to personalize your Atlasphere.</p>
            <label for="name-input" class="sr-only">Enter your name</label>
            <input type="text" id="name-input" placeholder="Enter your name..." maxlength="50">
            <button id="name-prompt-button">Begin Journey</button>
        </div>
    </div>

    <script>
        // --- Configuration & Constants ---
        const MAP_DATA_URL = 'https://unpkg.com/world-atlas@2/countries-110m.json';
        const COUNTRY_NAMES_URL = 'https://unpkg.com/world-atlas@1/world/110m.tsv'; // Contains ISO n3, name
        // Flag API using ISO A2 lowercase codes (e.g., 'us', 'de')
        // Using flagcdn.com - provides SVG and PNG flags. Using PNG for simplicity in canvas. w80 = 80px width.
        const FLAG_URL_TEMPLATE = 'https://flagcdn.com/w80/{iso_a2_lower}.png'; // For Globe texture (canvas)
        const FLAG_SVG_URL_TEMPLATE = 'https://flagcdn.com/{iso_a2_lower}.svg'; // For SVG map patterns

        const flagIsoOverrides = { KV: 'XK' };
        const continentOrder = ['Africa', 'Asia', 'Europe', 'North America', 'Oceania', 'South America', 'Antarctica'];
        const MAX_SEARCH_RESULTS = 12;
        const MIN_ZOOM = 1; const MAX_ZOOM = 18;
        const INITIAL_SVG_WIDTH = 960; const INITIAL_SVG_HEIGHT = 500;
        const DEG2RAD = Math.PI / 180;
        // Model anchors: ratio of total countries visited -> estimated percentile.
        // Update these with real research to make the banner authoritative.
        const travelPercentileAnchors = [
            { ratio: 0.0, percentile: 0 },
            { ratio: 0.01, percentile: 55 },
            { ratio: 0.02, percentile: 65 },
            { ratio: 0.05, percentile: 78 },
            { ratio: 0.08, percentile: 86 },
            { ratio: 0.12, percentile: 91 },
            { ratio: 0.18, percentile: 95 },
            { ratio: 0.25, percentile: 97 },
            { ratio: 0.35, percentile: 98.4 },
            { ratio: 0.5, percentile: 99.1 },
            { ratio: 0.7, percentile: 99.6 },
            { ratio: 0.85, percentile: 99.85 },
            { ratio: 1.0, percentile: 99.97 }
        ];

        // --- State Variables ---
        const visitedCountries = new Set(); // Stores ISO n3 IDs of visited countries
        let countryFeatures = []; // Array of GeoJSON features for countries
        let countryMetaById = {}; // Map from ISO n3 ID to metadata
        let countryFeatureById = {}; // Map from ISO n3 ID to GeoJSON feature
        let countryList = []; // Sorted list of countries for search
        let totalCountries = 0; // Total number of valid countries loaded
        let currentTransform = d3.zoomIdentity; // Current D3 zoom transform
        let activeView = 'map-view'; // Current active view ('map-view' or 'globe-view')
        let globeAnimationId = null; // ID for the globe animation frame request
        let userName = null; // User's entered name
        let isNameEntered = false; // Flag: true if user has entered a name
        let firstClickData = null; // Stores data of the first country click before name entry
        let searchResults = []; // Current search results
        let searchSelectedIndex = -1; // Keyboard navigation index
        let currentSearchQuery = ''; // Current search query
        let globeRotationTween = null; // Track globe focus animation
        const flagImageCache = {}; // Simple cache for loaded flag images (for canvas)
        const flagLoadErrors = new Set(); // Track flags that failed to load

        // --- DOM Element References ---
        const mapContainer = document.getElementById('map-container');
        const mapSvg = d3.select("#world-map");
        const mapGroup = d3.select("#map-group");
        const flagPatternsGroup = d3.select("#flag-patterns");
        const tooltip = d3.select("#tooltip");
        const visitedCountElement = document.getElementById('visited-count');
        const countriesLeftElement = document.getElementById('countries-left');
        const countriesTotalElement = document.getElementById('countries-total');
        const visitedListDiv = document.getElementById('visited-list');
        const visitedListContainer = document.getElementById('visited-list-container');
        const progressBar = document.getElementById('progress-bar');
        const progressContainer = document.getElementById('progress-container');
        const viewTabs = document.getElementById('view-tabs');
        const mapViewPanel = document.getElementById('map-view');
        const globeViewPanel = document.getElementById('globe-view');
        const globeContainer = document.getElementById('globe-container');
        const globeCanvas = document.getElementById('globe-canvas');
        const globeLoadingIndicator = document.getElementById('globe-loading');
        const subtitleElement = document.getElementById('subtitle');
        const percentileBanner = document.getElementById('percentile-banner');
        const percentileMessage = document.getElementById('percentile-message');
        const percentileSubnote = document.getElementById('percentile-subnote');
        const countrySearchInput = document.getElementById('country-search');
        const searchResultsList = document.getElementById('search-results');
        const clearSearchButton = document.getElementById('clear-search');
        const searchHint = document.getElementById('search-hint');
        const downloadSummaryButton = document.getElementById('download-summary-button');
        const exportButton = document.getElementById('export-button');
        const importButton = document.getElementById('import-button');
        const importFileInput = document.getElementById('import-file');
        const visitedInfoSection = document.getElementById('visited-info');
        const resetButton = document.getElementById('reset-button');
        const mainTitleElement = document.getElementById('main-title');
        const visitedInfoLabelElement = document.getElementById('visited-info-label');
        const namePromptOverlay = document.getElementById('name-prompt-overlay');
        const namePromptDialog = document.getElementById('name-prompt-dialog');
        const nameInput = document.getElementById('name-input');
        const namePromptButton = document.getElementById('name-prompt-button');

        // --- D3 Map Setup Variables ---
        let projection; // D3 map projection
        let pathGenerator; // D3 path generator
        let zoom; // D3 zoom behavior

        // --- Three.js Globe Setup Variables ---
        let globeScene, globeCamera, globeRenderer, globeControls, globeSphere, starField, raycaster;
        let globeInitialized = false; // Flag: true if globe setup is complete
        let globeNeedsTextureUpdate = false; // Flag: true if globe texture needs regeneration
        let globeTextureCanvas = null; // Offscreen canvas for globe texture
        let globeTextureContext = null; // Context for offscreen canvas
        let globeTexture = null; // The Three.js texture object
        const GLOBE_TEXTURE_SIZE = 2048; // Power of 2 for texture performance

        // === INITIALIZATION & DATA LOADING ===

        function normalizeCountryId(rawId) {
            if (rawId === null || rawId === undefined) return null;
            const value = String(rawId).trim();
            if (!value) return null;
            if (/^\d+$/.test(value)) {
                return value.padStart(3, '0');
            }
            return null;
        }

        function normalizeIsoA2(rawIsoA2) {
            const value = (rawIsoA2 || '').trim().toUpperCase();
            if (!/^[A-Z]{2}$/.test(value)) return null;
            return flagIsoOverrides[value] || value;
        }

        function normalizeIsoA3(rawIsoA3) {
            const value = (rawIsoA3 || '').trim().toUpperCase();
            if (!/^[A-Z]{3}$/.test(value)) return null;
            return value;
        }

        function normalizeContinent(rawContinent) {
            const value = (rawContinent || '').trim();
            if (!value || value === '-99') return 'Other Regions';
            return value;
        }

        function estimateTravelPercentile(visitedCount, totalCount) {
            if (!totalCount || visitedCount <= 0) return 0;
            const ratio = Math.min(Math.max(visitedCount / totalCount, 0), 1);
            const anchors = travelPercentileAnchors;
            if (ratio <= anchors[0].ratio) return anchors[0].percentile;
            for (let i = 1; i < anchors.length; i++) {
                const left = anchors[i - 1];
                const right = anchors[i];
                if (ratio <= right.ratio) {
                    const leftScore = Math.log1p(left.ratio);
                    const rightScore = Math.log1p(right.ratio);
                    const ratioScore = Math.log1p(ratio);
                    const t = rightScore === leftScore ? 0 : (ratioScore - leftScore) / (rightScore - leftScore);
                    return left.percentile + t * (right.percentile - left.percentile);
                }
            }
            return anchors[anchors.length - 1].percentile;
        }

        function formatTopPercent(value) {
            if (value < 1) return value.toFixed(1).replace(/\.0$/, '');
            if (value < 10) return value.toFixed(1).replace(/\.0$/, '');
            return Math.round(value).toString();
        }

        function updatePercentileBanner() {
            if (!percentileBanner || !percentileMessage) return;
            if (!totalCountries || visitedCountries.size === 0) {
                percentileBanner.classList.add('hidden');
                return;
            }

            const visitedCount = visitedCountries.size;
            const percentile = estimateTravelPercentile(visitedCount, totalCountries);
            const topPercent = Math.max(100 - percentile, 0.01);
            const formattedTop = formatTopPercent(topPercent);
            const lead = visitedCount < 3 ? 'Great start' : 'Impressive';
            percentileMessage.textContent = `${lead}, you are in the top ${formattedTop}% of travelers on this planet.`;

            if (percentileSubnote) {
                percentileSubnote.textContent = 'Estimated from global travel patterns. Not an official statistic.';
            }
            percentileBanner.classList.remove('hidden');
        }

        /**
         * Initializes the application: loads data, sets up views and event listeners.
         */
        async function initializeApp() {
            subtitleElement.textContent = 'Loading exploration data...';
            try {
                // Load map topology and country name data in parallel
                const [worldData, countryNameData] = await Promise.all([
                    d3.json(MAP_DATA_URL),
                    d3.tsv(COUNTRY_NAMES_URL)
                ]);
                console.log("Atlasphere Systems: Map data loaded.");

                // Process country name data into metadata map
                countryMetaById = {};
                countryNameData.forEach(d => {
                    const id = normalizeCountryId(d.iso_n3);
                    const name = (d.name || '').trim();
                    const isoA3 = normalizeIsoA3(d.iso_a3);
                    const isoA2 = normalizeIsoA2(d.iso_a2);
                    if (!id || !name || !isoA3) return;

                    countryMetaById[id] = {
                        id,
                        name,
                        iso_a2: isoA2,
                        iso_a3: isoA3,
                        continent: normalizeContinent(d.continent),
                        region: (d.region_un || '').trim(),
                        subregion: (d.subregion || '').trim()
                    };
                });

                // Convert TopoJSON to GeoJSON features
                const allFeatures = topojson.feature(worldData, worldData.objects.countries).features;
                countryFeatures = allFeatures
                    .map(feature => {
                        const id = normalizeCountryId(feature.id);
                        const meta = id ? countryMetaById[id] : null;
                        if (!id || !meta || meta.name === 'Antarctica') return null;
                        feature.id = id;
                        feature.properties = feature.properties || {};
                        feature.properties.name = meta.name;
                        feature.properties.iso_a3 = meta.iso_a3;
                        feature.properties.iso_a2 = meta.iso_a2;
                        feature.properties.continent = meta.continent;
                        return feature;
                    })
                    .filter(Boolean);
                countryFeatureById = {};
                countryFeatures.forEach(feature => {
                    countryFeatureById[feature.id] = feature;
                });
                countryList = countryFeatures
                    .map(feature => ({ id: feature.id, name: feature.properties.name }))
                    .sort((a, b) => a.name.localeCompare(b.name));
                totalCountries = countryFeatures.length;
                console.log(`Atlasphere Systems: ${totalCountries} valid countries identified.`);

                // Initialize UI components and load state
                initializeMapView();
                setupViewSwitcher();
                setupDownloadButton();
                setupResetButton();
                setupNamePrompt(); // Setup listener for name prompt
                setupSearch(); // Setup search and keyboard navigation
                setupDataPortability(); // Setup export/import
                loadState(); // Load visited countries AND user name from localStorage

                // Initial UI update based on loaded state
                updateVisitedInfo();
                updateTitles(); // Update titles based on loaded name (calls switchView internally)

                // Apply initial styles AFTER drawing countries
                applyInitialMapStyles();

                mapSvg.call(zoom.transform, d3.zoomIdentity); // Reset zoom initially
                window.addEventListener('resize', handleResize); // Handle window resizing

            } catch (error) {
                // Handle errors during data loading
                console.error("ERROR: Failed to load map data.", error);
                if (mapContainer) {
                    mapContainer.innerHTML = `<p class='text-red-500 text-center p-4'>Error: Map data could not be loaded. Please check your connection and refresh.</p>`;
                }
                 if (subtitleElement) {
                    subtitleElement.textContent = 'Map Initialization Failed.';
                }
            }
        }

        /**
         * Initializes the D3 map view components (projection, zoom, drawing).
         */
        function initializeMapView() {
            initializeProjection();
            initializeZoom();
            drawCountries(); // Draw paths first
            console.log("Map View Initialized.");
        }

        /**
         * Sets up the D3 Mercator projection and path generator.
         */
        function initializeProjection() {
            // Scale projection based on initial SVG width
            projection = d3.geoMercator()
                .scale(INITIAL_SVG_WIDTH / (2 * Math.PI) * 0.95) // Adjust scale factor
                .translate([INITIAL_SVG_WIDTH / 2, INITIAL_SVG_HEIGHT / 1.5]); // Center map slightly lower
            pathGenerator = d3.geoPath().projection(projection);
        }

        /**
         * Sets up the D3 zoom behavior for the map.
         */
        function initializeZoom() {
            zoom = d3.zoom()
                .scaleExtent([MIN_ZOOM, MAX_ZOOM]) // Min/max zoom levels
                // Limit panning extent slightly beyond initial view
                .translateExtent([[-INITIAL_SVG_WIDTH * 0.5, -INITIAL_SVG_HEIGHT * 0.5], [INITIAL_SVG_WIDTH * 1.5, INITIAL_SVG_HEIGHT * 1.5]])
                .on("start", handleZoomStart) // On zoom start event
                .on("zoom", handleZoom)     // On zoom event
                .on("end", handleZoomEnd);     // On zoom end event
            mapSvg.call(zoom)
                 .on("dblclick.zoom", null); // Disable double-click zoom
        }

        /**
         * Draws the country paths onto the SVG map.
         */
        function drawCountries() {
            mapGroup.selectAll(".country")
                .data(countryFeatures, d => d.id) // Use country ID as key
                .join("path") // Use join for enter/update/exit
                .attr("class", "country")
                .attr("data-country-id", d => d.id)
                .attr("data-country-name", d => d.properties.name)
                .attr("data-iso-a2", d => (d.properties.iso_a2 || '').toLowerCase()) // Store lowercase a2 for flag URL
                .attr("d", pathGenerator) // Generate path data
                // Attach event listeners
                .on("mouseover", handleMouseOver)
                .on("mousemove", handleMouseMove)
                .on("mouseout", handleMouseOut)
                .on("mousedown", handleMouseDown)
                .on("mouseup", handleMouseUp)
                .on("click", handleCountryClick); // Unified click handler

            console.log("Country boundaries rendered:", mapGroup.selectAll(".country").size());
        }

        /**
         * Applies initial 'visited' styles (flags) after countries are drawn and state is loaded.
         */
        function applyInitialMapStyles() {
            mapGroup.selectAll(".country")
                .each(function(d) {
                    const countryElement = d3.select(this);
                    if (visitedCountries.has(d.id)) {
                        applyFlagPattern(countryElement, d.id, d.properties.iso_a2);
                    } else {
                        removeFlagPattern(countryElement, d.id); // Ensure non-visited are default
                    }
                });
             // Ensure globe texture reflects loaded state if globe view is active or becomes active
             globeNeedsTextureUpdate = true;
             if (activeView === 'globe-view' && globeInitialized) {
                 updateGlobeTexture();
             }
        }


        // === VIEW SWITCHING ===

        /**
         * Sets up the event listener for the view switcher tabs.
         */
        function setupViewSwitcher() {
            viewTabs.addEventListener('click', (event) => {
                // Check if a tab button was clicked and it's not already active
                if (event.target.classList.contains('tab-button') && !event.target.classList.contains('active')) {
                    const viewId = event.target.getAttribute('data-view');
                    switchView(viewId);
                }
            });
        }

        /**
         * Switches the active view between the map and the globe.
         * @param {string} viewId - The ID of the view to switch to ('map-view' or 'globe-view').
         */
        function switchView(viewId) {
            // No change needed if already active and globe is initialized (or not globe view)
            if (activeView === viewId && (viewId !== 'globe-view' || globeInitialized)) return;

            // Pause globe animation if switching away from it
            if (activeView === 'globe-view' && globeAnimationId) {
                cancelAnimationFrame(globeAnimationId);
                globeAnimationId = null;
                console.log("3D Globe simulation paused.");
            }

            activeView = viewId;

            // Update tab button styles
            viewTabs.querySelectorAll('.tab-button').forEach(button => {
                button.classList.toggle('active', button.getAttribute('data-view') === viewId);
            });

            // Toggle visibility of view panels
            mapViewPanel.classList.toggle('active', viewId === 'map-view');
            globeViewPanel.classList.toggle('active', viewId === 'globe-view');

            // Update subtitle based on active view and user name
            updateSubtitle();

            // Initialize or resume globe animation if switching to globe view
            if (viewId === 'globe-view') {
                // Use requestAnimationFrame to ensure layout is calculated before globe setup
                requestAnimationFrame(() => {
                    if (!globeInitialized) {
                        setupGlobeScene(); // Initialize globe if first time
                    } else {
                         handleResize(); // Ensure correct size on switch
                         if (!globeAnimationId) {
                            animateGlobe(); // Resume animation if paused
                            console.log("3D Globe simulation resumed.");
                         }
                         // Always mark for update when switching to globe view
                         // to ensure highlights are correct
                         globeNeedsTextureUpdate = true;
                         updateGlobeTexture(); // Trigger immediate update if possible
                    }
                });
            }
            console.log(`View switched to: ${viewId}`);
        }

        // === SEARCH & FOCUS ===

        function setupSearch() {
            if (!countrySearchInput || !searchResultsList) return;

            countrySearchInput.addEventListener('input', (event) => {
                updateSearchResults(event.target.value);
            });

            countrySearchInput.addEventListener('keydown', handleSearchKeydown);

            searchResultsList.addEventListener('click', (event) => {
                const item = event.target.closest('.search-result');
                if (!item) return;
                const countryId = item.getAttribute('data-country-id');
                const feature = countryFeatureById[countryId];
                if (feature) {
                    selectSearchResult(feature);
                }
            });

            if (clearSearchButton) {
                clearSearchButton.addEventListener('click', clearSearch);
            }
        }

        function updateSearchResults(query) {
            currentSearchQuery = (query || '').trim();
            if (!currentSearchQuery) {
                searchResults = [];
                searchSelectedIndex = -1;
                renderSearchResults();
                return;
            }

            const normalizedQuery = currentSearchQuery.toLowerCase();
            const matches = countryList
                .filter(entry => entry.name.toLowerCase().includes(normalizedQuery))
                .slice(0, MAX_SEARCH_RESULTS);

            searchResults = matches
                .map(entry => countryFeatureById[entry.id])
                .filter(Boolean);

            searchSelectedIndex = searchResults.length ? 0 : -1;
            renderSearchResults();
        }

        function renderSearchResults() {
            if (!searchResultsList) return;
            searchResultsList.innerHTML = '';

            if (!currentSearchQuery) {
                if (searchHint) {
                    searchHint.textContent = 'Type to search. Use Up/Down + Enter to select.';
                }
                return;
            }

            if (searchResults.length === 0) {
                if (searchHint) {
                    searchHint.textContent = 'No matches. Try another name.';
                }
                return;
            }

            if (searchHint) {
                searchHint.textContent = `Showing ${searchResults.length} result(s). Use Up/Down + Enter to select.`;
            }

            searchResults.forEach((feature, index) => {
                const isVisited = visitedCountries.has(feature.id);
                const li = document.createElement('li');
                li.className = `search-result${isVisited ? ' visited' : ''}${index === searchSelectedIndex ? ' active' : ''}`;
                li.setAttribute('role', 'option');
                li.setAttribute('aria-selected', index === searchSelectedIndex ? 'true' : 'false');
                li.setAttribute('data-country-id', feature.id);

                const nameSpan = document.createElement('span');
                nameSpan.textContent = feature.properties.name;

                const metaSpan = document.createElement('span');
                metaSpan.className = 'search-meta';
                metaSpan.textContent = isVisited ? 'Visited' : 'Not visited';

                li.appendChild(nameSpan);
                li.appendChild(metaSpan);
                searchResultsList.appendChild(li);
            });

            const activeItem = searchResultsList.querySelector('.search-result.active');
            if (activeItem) {
                activeItem.scrollIntoView({ block: 'nearest' });
            }
        }

        function handleSearchKeydown(event) {
            if (!searchResults.length) return;

            if (event.key === 'ArrowDown') {
                event.preventDefault();
                searchSelectedIndex = Math.min(searchSelectedIndex + 1, searchResults.length - 1);
                renderSearchResults();
            } else if (event.key === 'ArrowUp') {
                event.preventDefault();
                searchSelectedIndex = Math.max(searchSelectedIndex - 1, 0);
                renderSearchResults();
            } else if (event.key === 'Enter') {
                event.preventDefault();
                const feature = searchResults[searchSelectedIndex];
                if (feature) {
                    selectSearchResult(feature);
                }
            } else if (event.key === 'Escape') {
                clearSearch();
            }
        }

        function selectSearchResult(feature) {
            if (!feature) return;
            if (!isNameEntered && visitedCountries.size === 0) {
                firstClickData = { source: 'search', d: feature, focus: true };
                showNamePrompt();
                return;
            }

            processCountryToggle(feature.id, feature.properties.iso_a2);
            focusOnCountry(feature);
        }

        function clearSearch() {
            if (countrySearchInput) {
                countrySearchInput.value = '';
            }
            currentSearchQuery = '';
            searchResults = [];
            searchSelectedIndex = -1;
            renderSearchResults();
        }

        function focusOnCountry(feature) {
            if (!feature) return;

            if (activeView === 'map-view' && pathGenerator && zoom) {
                const bounds = pathGenerator.bounds(feature);
                const dx = bounds[1][0] - bounds[0][0];
                const dy = bounds[1][1] - bounds[0][1];
                if (dx > 0 && dy > 0) {
                    const x = (bounds[0][0] + bounds[1][0]) / 2;
                    const y = (bounds[0][1] + bounds[1][1]) / 2;
                    const scale = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, 0.9 / Math.max(dx / INITIAL_SVG_WIDTH, dy / INITIAL_SVG_HEIGHT)));
                    const translate = [INITIAL_SVG_WIDTH / 2 - scale * x, INITIAL_SVG_HEIGHT / 2 - scale * y];
                    mapSvg.transition()
                        .duration(850)
                        .call(zoom.transform, d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale));
                }
            } else if (activeView === 'globe-view') {
                focusGlobeOnCountry(feature);
            }
        }

        function shortestAngleDelta(target, current) {
            const delta = target - current;
            return Math.atan2(Math.sin(delta), Math.cos(delta));
        }

        function focusGlobeOnCountry(feature) {
            if (!globeSphere || !globeControls) return;
            const [lon, lat] = d3.geoCentroid(feature);
            const targetX = lat * DEG2RAD;
            const targetY = -lon * DEG2RAD;
            const startX = globeSphere.rotation.x;
            const startY = globeSphere.rotation.y;
            const deltaX = targetX - startX;
            const deltaY = shortestAngleDelta(targetY, startY);
            const startTime = performance.now();
            const duration = 900;

            if (globeRotationTween) {
                cancelAnimationFrame(globeRotationTween);
            }

            globeControls.autoRotate = false;
            const animate = (time) => {
                const t = Math.min((time - startTime) / duration, 1);
                const eased = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
                globeSphere.rotation.x = startX + deltaX * eased;
                globeSphere.rotation.y = startY + deltaY * eased;

                if (t < 1) {
                    globeRotationTween = requestAnimationFrame(animate);
                } else {
                    globeRotationTween = null;
                    setTimeout(() => {
                        if (globeControls) globeControls.autoRotate = true;
                    }, 1200);
                }
            };
            globeRotationTween = requestAnimationFrame(animate);
        }

        // === MAP VIEW EVENT HANDLERS ===

        /** Handles the start of a D3 zoom/pan event. */
        function handleZoomStart() {
            tooltip.style("display", "none"); // Hide tooltip during zoom
            mapContainer.style.cursor = 'grabbing'; // Change cursor
        }

        /** Handles the D3 zoom/pan event, transforming the map group. */
        function handleZoom(event) {
            currentTransform = event.transform;
            mapGroup.attr("transform", currentTransform); // Apply transform to map group

            // Adjust stroke width based on zoom level for better visibility
            const k = currentTransform.k; // Current scale factor
            const baseStrokeWidth = Math.max(0.1, 0.6 / k); // Clamp min stroke width
            const visitedStrokeWidth = Math.max(0.2, 0.8 / k); // Clamp min stroke width

            mapGroup.selectAll(".country:not(.visited)").style("stroke-width", baseStrokeWidth);
            mapGroup.selectAll(".country.visited").style("stroke-width", visitedStrokeWidth);
        }

        /** Handles the end of a D3 zoom/pan event. */
        function handleZoomEnd() {
            mapContainer.style.cursor = 'grab'; // Restore cursor
        }

        /** Shows the tooltip on country mouseover. */
        function handleMouseOver(event, d) {
            const name = d.properties?.name;
            // Show tooltip only if country has a valid name
            if (name && name !== 'Unknown') {
                tooltip.html(`${name}`) // Set tooltip content
                       .style("display", "block"); // Make tooltip visible
                handleMouseMove(event); // Position tooltip initially
            }
             // Optional: Slightly highlight on hover even if visited
            // d3.select(event.currentTarget).raise(); // Bring to front
        }

        /** Updates the tooltip position on mouse move. */
        function handleMouseMove(event) {
            // Position tooltip slightly offset from the cursor
            // Consider map container boundaries to prevent tooltip going off-screen
            const mapBounds = mapContainer.getBoundingClientRect();
            const tooltipNode = tooltip.node();
            if (!tooltipNode) return; // Exit if tooltip node doesn't exist yet

            const tooltipWidth = tooltipNode.offsetWidth;
            const tooltipHeight = tooltipNode.offsetHeight;

            // Calculate potential positions
            let x = event.pageX + 15;
            let y = event.pageY + 10;

            // Adjust if tooltip goes off right edge
            if (x + tooltipWidth > window.innerWidth) {
                x = event.pageX - tooltipWidth - 15;
            }
            // Adjust if tooltip goes off bottom edge
            if (y + tooltipHeight > window.innerHeight) {
                 y = event.pageY - tooltipHeight - 10;
            }
            // Adjust if tooltip goes off left edge (less common)
            if (x < 0) {
                x = 5;
            }
            // Adjust if tooltip goes off top edge (less common)
             if (y < 0) {
                y = 5;
            }


            tooltip.style("left", x + "px")
                   .style("top", y + "px");
        }

        /** Hides the tooltip on country mouseout. */
        function handleMouseOut(event) {
            tooltip.style("display", "none");
             // Optional: Reset any hover effect
            // d3.select(event.currentTarget); //.lower(); // Send back if raised
        }

        /** Adds a 'pressed' visual state on mouse down (only for non-visited). */
        function handleMouseDown(event, d) {
            if (d?.properties?.name && d.properties.name !== 'Unknown' && !visitedCountries.has(d.id)) {
                 d3.select(event.currentTarget).classed("pressed", true);
            }
            tooltip.style("display", "none"); // Hide tooltip on press
            event.preventDefault(); // Prevent text selection/dragging issues
        }

        /** Removes the 'pressed' visual state on mouse up. */
        function handleMouseUp(event) {
            d3.select(event.currentTarget).classed("pressed", false);
        }

        /**
         * Handles the click event on a country path (SVG Map).
         * Toggles visited status or shows name prompt if first click.
         */
        function handleCountryClick(event, d) {
            // Ignore clicks that are part of a drag/zoom gesture
            if (event.defaultPrevented) return;

            // Check if this is the very first country click AND name hasn't been entered
            if (!isNameEntered && visitedCountries.size === 0) {
                firstClickData = { source: 'map', d }; // Store click data for later
                showNamePrompt(); // Show the name input dialog
                return; // Stop processing until name is entered
            }

            // Normal country click logic (if name is already entered or it's not the first click)
            processCountryToggle(d.id, d.properties?.iso_a2); // Pass ID and A2 code
        }

        // === FLAG PATTERN MANAGEMENT (SVG MAP) ===

        /**
         * Applies the flag pattern fill to a specific country SVG element.
         * Creates the pattern definition if it doesn't exist.
         * @param {d3.Selection} countryElement - The D3 selection of the country path.
         * @param {string} countryId - The ISO n3 ID of the country.
         * @param {string} isoA2 - The ISO a2 code of the country.
         */
        function applyFlagPattern(countryElement, countryId, isoA2) {
            if (!isoA2 || flagLoadErrors.has(countryId)) { // Don't apply if no A2 or flag previously failed
                countryElement.style("fill", flagLoadErrors.has(countryId) ? 'var(--flag-error-fill)' : 'var(--flag-fallback-fill)'); // Fallback color
                countryElement.classed("visited", true);
                countryElement.classed("flag-error", flagLoadErrors.has(countryId));
                return;
            }

            const patternId = `pattern-${countryId}`;
            const flagSvgUrl = FLAG_SVG_URL_TEMPLATE.replace('{iso_a2_lower}', isoA2.toLowerCase());

            // Check if pattern already exists
            let pattern = flagPatternsGroup.select(`#${patternId}`);
            if (pattern.empty()) {
                // Create the pattern
                pattern = flagPatternsGroup.append("pattern")
                    .attr("id", patternId)
                    .attr("patternUnits", "objectBoundingBox") // Relative to the shape's bounding box
                    .attr("width", 1) // Covers 100% width of bbox
                    .attr("height", 1) // Covers 100% height of bbox
                    // Preserve aspect ratio is handled by the image inside
                    .attr("viewBox", "0 0 1 1") // Needed for objectBoundingBox scaling
                    .attr("preserveAspectRatio", "none"); // Pattern itself doesn't preserve

                pattern.append("rect") // Optional background for the pattern tile itself
                    .attr("width", 1)
                    .attr("height", 1)
                    .attr("fill", "var(--bg-tertiary)"); // Background while flag loads or if transparent

                pattern.append("image")
                    .attr("class", "flag-pattern") // Assign class for CSS styling
                    .attr("xlink:href", flagSvgUrl)
                    .attr("x", 0)
                    .attr("y", 0)
                    .attr("width", 1) // Image covers pattern width
                    .attr("height", 1) // Image covers pattern height
                    .attr("preserveAspectRatio", "xMidYMid slice") // *** This is the key attribute ***
                    .on("error", function() { // Handle flag loading error
                        console.error(`Failed to load flag SVG: ${flagSvgUrl}`);
                        flagLoadErrors.add(countryId); // Mark this flag as failed
                        // Remove the broken image and pattern
                        d3.select(this.parentNode).remove();
                        // Re-apply style with error fill
                        countryElement.style("fill", 'var(--flag-error-fill)')
                                      .classed("visited", true)
                                      .classed("flag-error", true);
                        // Potentially trigger globe update if needed
                        globeNeedsTextureUpdate = true;
                    });
            }

            // Apply the pattern fill
            countryElement.style("fill", `url(#${patternId})`);
            countryElement.classed("visited", true);
            countryElement.classed("flag-error", false); // Ensure error class is removed if previously set
        }

        /**
         * Removes the flag pattern fill and resets the style of a country SVG element.
         * Removes the corresponding pattern definition.
         * @param {d3.Selection} countryElement - The D3 selection of the country path.
         * @param {string} countryId - The ISO n3 ID of the country.
         */
        function removeFlagPattern(countryElement, countryId) {
            const patternId = `pattern-${countryId}`;

            // Reset fill to default CSS value
            countryElement.style("fill", null); // Use CSS default (--bg-tertiary)
            countryElement.classed("visited", false);
            countryElement.classed("flag-error", false);

            // Remove the pattern definition from <defs>
            flagPatternsGroup.select(`#${patternId}`).remove();
            flagLoadErrors.delete(countryId); // Clear any previous error state
        }


        // === GLOBE VIEW (THREE.JS) ===

        /**
         * Sets up the initial Three.js scene, camera, renderer, controls, and objects.
         */
        function setupGlobeScene() {
            // Prevent re-initialization
            if (globeInitialized) return;
            console.log("Initializing 3D Globe...");
            globeLoadingIndicator.style.display = 'block'; // Show loading indicator

            // Get container dimensions
            const width = globeContainer.clientWidth;
            const height = globeContainer.clientHeight;

            // If dimensions are zero (e.g., container not visible yet), retry shortly
            if (width === 0 || height === 0) {
                console.warn("Globe container dimensions unavailable. Retrying...");
                setTimeout(setupGlobeScene, 100); // Retry after 100ms
                return;
            }

            try {
                // Scene
                globeScene = new THREE.Scene();
                raycaster = new THREE.Raycaster(); // For click detection

                // Camera
                const aspect = width / height;
                globeCamera = new THREE.PerspectiveCamera(50, aspect, 0.1, 1000); // FOV slightly reduced
                globeCamera.position.z = 3.5; // Start slightly further back

                // Renderer
                globeRenderer = new THREE.WebGLRenderer({
                    canvas: globeCanvas, // Use existing canvas element
                    antialias: true,     // Smoother edges
                    alpha: true          // Allow transparency for background
                });
                globeRenderer.setSize(width, height); // Set size
                globeRenderer.setPixelRatio(window.devicePixelRatio); // Adjust for high-DPI screens

                // Lighting
                globeScene.add(new THREE.AmbientLight(0xaaaaaa, 0.8)); // Softer ambient
                const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
                dirLight.position.set(5, 3, 5);
                globeScene.add(dirLight);

                // Starfield Background
                createStarfield();

                // Offscreen Canvas for Texture
                globeTextureCanvas = document.createElement('canvas');
                globeTextureCanvas.width = GLOBE_TEXTURE_SIZE;
                globeTextureCanvas.height = GLOBE_TEXTURE_SIZE / 2; // Equirectangular aspect ratio
                globeTextureContext = globeTextureCanvas.getContext('2d');

                // Globe Sphere Mesh
                const geometry = new THREE.SphereGeometry(1, 64, 64); // Increased segments for smoother UV mapping
                globeTexture = new THREE.CanvasTexture(globeTextureCanvas); // Create texture from canvas
                globeTexture.needsUpdate = true; // Initial update needed

                const material = new THREE.MeshPhongMaterial({
                    map: globeTexture,
                    color: 0xffffff, // Base color if texture fails
                    specular: 0x222222, // Slightly more specular
                    shininess: 15,     // Slightly shinier
                    transparent: false,
                });
                globeSphere = new THREE.Mesh(geometry, material);
                globeScene.add(globeSphere);

                // Orbit Controls (for user interaction)
                globeControls = new THREE.OrbitControls(globeCamera, globeRenderer.domElement);
                globeControls.enableDamping = true;
                globeControls.dampingFactor = 0.05;
                globeControls.enablePan = false; // Disable panning
                globeControls.minDistance = 1.8; // Adjusted min zoom
                globeControls.maxDistance = 10;  // Adjusted max zoom
                globeControls.rotateSpeed = 0.4;
                globeControls.zoomSpeed = 0.8;
                globeControls.autoRotate = true;
                globeControls.autoRotateSpeed = 0.5; // Slower auto-rotate

                // Add click listener to the canvas
                globeRenderer.domElement.addEventListener('click', handleGlobeClick, false);


                // Mark initialization complete and trigger first texture update
                globeInitialized = true;
                globeNeedsTextureUpdate = true; // Signal initial texture draw needed
                updateGlobeTexture(); // Perform initial texture draw

                // Start the animation loop if not already running
                if (!globeAnimationId) {
                    animateGlobe();
                }
                handleResize(); // Ensure correct sizing
                console.log("3D Globe Initialized.");

            } catch (error) {
                // Handle errors during Three.js setup
                console.error("ERROR: Failed to initialize 3D Globe.", error);
                if (globeContainer) {
                    globeContainer.innerHTML = `<p class='text-red-500 text-center p-4'>Error: 3D Globe failed to load.</p>`;
                }
            } finally {
                // Hide loading indicator regardless of success/failure
                globeLoadingIndicator.style.display = 'none';
            }
        }

        /**
         * Creates a starfield background using THREE.Points.
         */
        function createStarfield() {
            const starQty = 10000; // Number of stars
            const positions = new Float32Array(starQty * 3);
            const colors = new Float32Array(starQty * 3);
            const color = new THREE.Color();

            for (let i = 0; i < starQty; i++) {
                const i3 = i * 3;
                // Position stars within a large sphere
                const radius = 200 + Math.random() * 300; // Place stars far away
                const theta = Math.random() * Math.PI * 2; // Random angle around Y axis
                const phi = Math.acos((Math.random() * 2) - 1); // Random angle from Y axis

                positions[i3]     = radius * Math.sin(phi) * Math.cos(theta);
                positions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
                positions[i3 + 2] = radius * Math.cos(phi);

                // Assign slightly varying colors (mostly white/blueish)
                color.setHSL(Math.random() * 0.1 + 0.55, 0.3, Math.random() * 0.4 + 0.5);
                colors[i3]     = color.r;
                colors[i3 + 1] = color.g;
                colors[i3 + 2] = color.b;
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            const material = new THREE.PointsMaterial({
                size: 1.0, // Size of each star point
                blending: THREE.AdditiveBlending, // Make stars brighter where they overlap
                depthWrite: false, // Don't obscure objects behind them
                transparent: true,
                opacity: 0.8, // Slight transparency
                vertexColors: true // Use the colors defined in the geometry
            });

            starField = new THREE.Points(geometry, material);
            globeScene.add(starField);
        }

         /**
          * Handles click events on the globe canvas for country selection.
          */
         function handleGlobeClick(event) {
             if (!globeInitialized || !raycaster || !globeCamera || !globeSphere || countryFeatures.length === 0) return;

             // --- Calculate Mouse Coordinates ---
             // Get the position and size of the canvas element
             const rect = globeRenderer.domElement.getBoundingClientRect();
             const mouse = new THREE.Vector2();
             // Calculate mouse position in normalized device coordinates (-1 to +1)
             // (event.clientX, event.clientY) are coordinates relative to the viewport
             // We need to convert them relative to the canvas element
             mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
             mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

             // --- Raycasting ---
             // Update the picking ray with the camera and mouse position
             raycaster.setFromCamera(mouse, globeCamera);
             // Calculate objects intersecting the picking ray (only check the globe sphere)
             const intersects = raycaster.intersectObject(globeSphere);

             // --- Process Intersection ---
             if (intersects.length > 0) { // Check if the ray hit the sphere
                 const intersect = intersects[0]; // Get the closest intersection
                 const point = intersect.point; // Intersection point in 3D world space

                 // --- Convert 3D Point to Lat/Lon ---
                 // Convert the 3D intersection point on the sphere surface to spherical coordinates (latitude/longitude)
                 // Assuming sphere radius is 1 and centered at the origin (0,0,0)
                 const radius = 1;
                 // Latitude: Angle from the XZ plane (horizontal plane). Calculated using asin(y/radius).
                 // Convert from radians to degrees. Note: Three.js Y is up.
                 const latitude = Math.asin(point.y / radius) * (180 / Math.PI);
                 // Longitude: Angle around the Y axis, measured from the positive Z axis in the XZ plane. Calculated using atan2(x, z).
                 // Convert from radians to degrees.
                 const longitude = Math.atan2(point.x, point.z) * (180 / Math.PI);

                 // --- Find Clicked Country ---
                 // Iterate through GeoJSON features to find which country contains the calculated [longitude, latitude] point
                 const clickedCountry = countryFeatures.find(feature => {
                     // d3.geoContains checks if a GeoJSON object contains a given point [longitude, latitude]
                     return d3.geoContains(feature, [longitude, latitude]);
                 });

                 // --- Handle Country Click ---
                 if (clickedCountry) { // If a country was found at the clicked point
                     console.log(`Globe Click: ${clickedCountry.properties.name} (Lat: ${latitude.toFixed(2)}, Lon: ${longitude.toFixed(2)})`);

                      // Check if this is the very first country click AND name hasn't been entered
                     if (!isNameEntered && visitedCountries.size === 0) {
                         firstClickData = { source: 'globe', d: clickedCountry }; // Store click data
                         showNamePrompt(); // Show the name input dialog
                         return; // Stop processing until name is entered
                     }

                     // Process the toggle (add/remove visited status)
                     processCountryToggle(clickedCountry.id, clickedCountry.properties.iso_a2);

                 } else {
                     // console.log("Globe Click: Ocean or no country found at point."); // Clicked on water or area with no data
                 }
             }
         }


        /**
         * Updates the texture applied to the globe sphere, drawing base map and visited country flags.
         * Uses an offscreen canvas (globeTextureCanvas).
         */
        function updateGlobeTexture() {
            // Ensure globe is initialized, data is available, and context exists
            if (!globeInitialized || !countryFeatures.length || !globeSphere || !globeTextureContext) {
                // console.warn("Globe texture update skipped: prerequisites not met.");
                globeNeedsTextureUpdate = false; // Reset flag if skipped
                return;
            }
            console.log("Updating globe texture...");

            try {
                const ctx = globeTextureContext;
                const canvas = globeTextureCanvas;

                // Get computed colors from CSS variables for theming
                const oceanColor = getComputedStyle(document.documentElement).getPropertyValue('--globe-ocean').trim() || '#080a10';
                const landColor = getComputedStyle(document.documentElement).getPropertyValue('--globe-land').trim() || '#252830';
                const landOutlineColor = getComputedStyle(document.documentElement).getPropertyValue('--globe-land-outline').trim() || '#404550';
                const visitedOutlineColor = getComputedStyle(document.documentElement).getPropertyValue('--globe-visited-outline').trim() || '#66ccff';
                const flagErrorFill = getComputedStyle(document.documentElement).getPropertyValue('--flag-error-fill').trim() || '#444444';
                const flagFallbackFill = getComputedStyle(document.documentElement).getPropertyValue('--flag-fallback-fill').trim() || '#6fe3ff';

                // 1. Clear canvas and fill background with ocean color
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = oceanColor;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // 2. Setup D3 projection and path generator for the texture canvas
                // Use Equirectangular projection for mapping onto the sphere texture
                const textureProjection = d3.geoEquirectangular()
                    .fitSize([canvas.width, canvas.height], { type: "Sphere" }); // Fit projection to canvas dimensions
                const texturePathGenerator = d3.geoPath()
                    .projection(textureProjection)
                    .context(ctx); // Draw directly onto the 2D canvas context

                // 3. Draw ALL countries with base land color and outline
                ctx.beginPath(); // Start a single path for all base countries
                // Generate path data for all country features
                texturePathGenerator({type: "FeatureCollection", features: countryFeatures});
                ctx.fillStyle = landColor; // Set fill color for land
                ctx.fill(); // Fill all landmasses
                ctx.strokeStyle = landOutlineColor; // Set outline color
                ctx.lineWidth = 0.5; // Fine outline for the base map
                ctx.stroke(); // Draw the outlines

                // 4. Draw visited countries highlighted ON TOP with flags
                const visitedFeatures = countryFeatures.filter(f => visitedCountries.has(f.id));

                // Use Promise.all to load all necessary flags concurrently before drawing
                const flagPromises = visitedFeatures.map(feature => {
                    const isoA2 = feature.properties.iso_a2;
                    const countryId = feature.id;

                    // Skip if no A2 code or if flag previously failed to load
                    if (!isoA2 || flagLoadErrors.has(countryId)) {
                        return Promise.resolve({
                            feature,
                            img: null,
                            error: flagLoadErrors.has(countryId),
                            missing: !isoA2
                        }); // Resolve immediately for error/skip case
                    }

                    const flagUrl = FLAG_URL_TEMPLATE.replace('{iso_a2_lower}', isoA2.toLowerCase());

                    // Return cached image if available to avoid reloading
                    if (flagImageCache[flagUrl]) {
                        return Promise.resolve({ feature, img: flagImageCache[flagUrl], error: false });
                    }

                    // Load image if not cached
                    return new Promise((resolve) => {
                        const img = new Image();
                        img.crossOrigin = "Anonymous"; // Needed for canvas tainting if using external flag source
                        img.onload = () => {
                            flagImageCache[flagUrl] = img; // Cache successful load
                            resolve({ feature, img, error: false });
                        };
                        img.onerror = () => {
                            console.error(`Failed to load flag PNG: ${flagUrl}`);
                            flagLoadErrors.add(countryId); // Mark as failed
                            resolve({ feature, img: null, error: true }); // Resolve with error flag
                        };
                        img.src = flagUrl;
                    });
                });

                // Once all flags are loaded (or have failed)
                Promise.all(flagPromises).then(results => {
                    results.forEach(({ feature, img, error, missing }) => {
                        ctx.beginPath(); // Begin path for this specific visited country
                        texturePathGenerator(feature); // Generate path data for the country

                        if (missing) {
                            // --- Draw Fallback State ---
                            ctx.fillStyle = flagFallbackFill;
                            ctx.fill();
                            ctx.strokeStyle = landOutlineColor;
                            ctx.lineWidth = 0.7;
                            ctx.stroke();
                        } else if (error || !img) {
                            // --- Draw Error State ---
                            // Fill with error color if flag failed or was skipped
                            ctx.fillStyle = flagErrorFill;
                            ctx.fill();
                            // Optionally add outline for error state
                            ctx.strokeStyle = landOutlineColor; // Use base outline color
                            ctx.lineWidth = 0.7; // Slightly thicker error outline
                            ctx.stroke();
                        } else {
                            // --- Draw Flag Image ---
                            // Draw the flag image clipped to the country shape
                            ctx.save(); // Save context state (including current path)
                            ctx.clip(); // Clip subsequent drawing operations to the country path

                            // Calculate bounding box of the country on the canvas
                            const bounds = texturePathGenerator.bounds(feature); // [[x0, y0], [x1, y1]]
                            const boundsWidth = bounds[1][0] - bounds[0][0];
                            const boundsHeight = bounds[1][1] - bounds[0][1];

                            if (boundsWidth > 0 && boundsHeight > 0) { // Ensure valid bounds
                                // --- Calculate Image Scaling (like CSS background-size: cover) ---
                                const imgAspect = img.naturalWidth / img.naturalHeight;
                                const boundsAspect = boundsWidth / boundsHeight;
                                let drawWidth, drawHeight, dx, dy;

                                if (imgAspect > boundsAspect) { // Image is wider than bounds aspect ratio
                                    // Fit height, calculate width based on aspect ratio
                                    drawHeight = boundsHeight;
                                    drawWidth = drawHeight * imgAspect;
                                    // Center horizontally
                                    dx = bounds[0][0] - (drawWidth - boundsWidth) / 2;
                                    dy = bounds[0][1];
                                } else { // Image is taller than bounds aspect ratio (or equal)
                                    // Fit width, calculate height based on aspect ratio
                                    drawWidth = boundsWidth;
                                    drawHeight = drawWidth / imgAspect;
                                    // Center vertically
                                    dx = bounds[0][0];
                                    dy = bounds[0][1] - (drawHeight - boundsHeight) / 2;
                                }

                                // Draw the image scaled and positioned to cover the bounds
                                try {
                                    ctx.drawImage(img, dx, dy, drawWidth, drawHeight);
                                } catch (drawError) {
                                    console.error(`Error drawing flag for ${feature.properties.name}:`, drawError);
                                    // Fill with error color as fallback if drawImage fails unexpectedly
                                    ctx.fillStyle = flagErrorFill;
                                    ctx.fill();
                                }
                            } else {
                                // If bounds are invalid (e.g., width/height 0), fill with error color
                                ctx.fillStyle = flagErrorFill;
                                ctx.fill();
                            }

                            ctx.restore(); // Restore context state (remove clipping path)

                            // --- Draw Visited Outline ---
                            // Draw outline ON TOP of the flag/clip area for better visibility
                            ctx.strokeStyle = visitedOutlineColor; // Use the visited outline color
                            ctx.lineWidth = 0.8; // Slightly thicker outline for visited countries
                            ctx.stroke(); // Stroke the country path again for the outline
                        }
                    });

                    // 5. Update the Three.js texture after all drawing is done
                    if (globeSphere && globeSphere.material.map) {
                        globeSphere.material.map.needsUpdate = true; // Signal Three.js texture needs upload to GPU
                    }
                    console.log("Globe texture updated with flags.");

                }).catch(loadError => {
                    // Catch errors from Promise.all itself (e.g., network issues fetching multiple flags)
                    console.error("Error loading one or more flags for globe:", loadError);
                });

            } catch (error) {
                // Catch synchronous errors during the texture update process
                console.error("Error during globe texture update:", error);
            } finally {
                // Mark update as complete, even if there were errors in the async flag loading/drawing
                globeNeedsTextureUpdate = false;
            }
        }


        /**
         * The main animation loop for the Three.js globe. Renders each frame.
         */
        function animateGlobe() {
            // Stop loop if globe is not initialized or scene doesn't exist
            if (!globeInitialized || !globeScene) {
                globeAnimationId = null; // Ensure ID is cleared
                return;
            }
            // Request the next frame from the browser
            globeAnimationId = requestAnimationFrame(animateGlobe);

            // Update globe texture if flagged (e.g., after a country click)
            // Note: Actual drawing happens async in updateGlobeTexture's Promise.all,
            // but this ensures the update process is initiated if needed.
            if (globeNeedsTextureUpdate) {
                 updateGlobeTexture(); // This initiates the update process
            }

            // Update controls (handles damping, auto-rotation)
            if (globeControls) globeControls.update();

            // Slowly rotate starfield for a dynamic background effect
            if (starField) {
                starField.rotation.y += 0.0001; // Adjust speed as desired
            }

            // Render the scene from the camera's perspective
            if (globeRenderer && globeScene && globeCamera) {
                globeRenderer.render(globeScene, globeCamera);
            }
        }

        // === NAME PROMPT LOGIC ===

        /** Shows the name prompt modal dialog. */
        function showNamePrompt() {
            if (namePromptOverlay) {
                namePromptOverlay.style.display = 'flex'; // Use flex to enable centering via align-items/justify-content
                if (nameInput) nameInput.focus(); // Focus the input field for convenience
            }
        }

        /** Hides the name prompt modal dialog. */
        function hideNamePrompt() {
            if (namePromptOverlay) {
                namePromptOverlay.style.display = 'none';
            }
        }

        /** Sets up event listeners for the name prompt dialog (button click, enter key). */
        function setupNamePrompt() {
            if (!namePromptButton || !nameInput) return; // Ensure elements exist

            // Handle click on the "Begin Journey" button
            namePromptButton.addEventListener('click', () => {
                const enteredName = nameInput.value.trim(); // Get trimmed name from input
                if (enteredName) { // Check if name is not empty
                    // Name entered successfully
                    userName = enteredName;
                    isNameEntered = true; // Set flag
                    localStorage.setItem('atlasphereUserName_v3', userName); // Save name to localStorage
                    updateTitles(); // Update UI titles (includes subtitle)
                    hideNamePrompt(); // Close the dialog

                    // If a country click triggered the prompt, process that click now
                    if (firstClickData) {
                        const { d, focus } = firstClickData; // Get stored click data
                        processCountryToggle(d.id, d.properties?.iso_a2); // Process the toggle
                        if (focus) {
                            focusOnCountry(d);
                        }
                        firstClickData = null; // Clear the stored click data
                    }
                    // Enable reset button if conditions met (now that name is entered)
                     updateVisitedInfo(); // Update button states based on new name/visited status
                } else {
                    // Optional: Provide feedback if name is empty
                    nameInput.style.borderColor = 'red'; // Simple visual feedback: red border
                    // Remove feedback after a short delay
                    setTimeout(() => { if(nameInput) nameInput.style.borderColor = ''; }, 1500);
                }
            });

            // Allow submitting the name by pressing Enter in the input field
            nameInput.addEventListener('keypress', (event) => {
                if (event.key === 'Enter') {
                    event.preventDefault(); // Prevent default form submission behavior (if any)
                    namePromptButton.click(); // Trigger button click programmatically
                }
            });
        }

        // === CORE LOGIC: COUNTRY TOGGLE & UI UPDATES ===

        /**
         * Processes the logic for adding/removing a country from the visited set
         * and updating the UI (map, globe, info panel) accordingly.
         * This is the central function called by both map and globe click handlers.
         * @param {string} countryId - The ISO n3 ID of the country to toggle.
         * @param {string} isoA2 - The ISO a2 code for flag lookup.
         */
        function processCountryToggle(countryId, isoA2) {
            // Ignore clicks on invalid features (should be pre-filtered, but double-check)
            const normalizedId = normalizeCountryId(countryId);
            const meta = normalizedId ? countryMetaById[normalizedId] : null;
            const name = meta?.name;
            if (!normalizedId || !meta || !name || name === 'Unknown') {
                console.warn(`Toggle ignored for invalid country ID: ${countryId}`);
                return;
            }
            const resolvedIsoA2 = isoA2 || meta.iso_a2;

            let changed = false; // Flag to track if the visited set actually changed

            // Find the corresponding SVG element for map updates (might be empty if map isn't drawn/visible)
            const countryElement = mapGroup.select(`.country[data-country-id="${normalizedId}"]`);

            // Toggle visited status in the Set
            if (visitedCountries.has(normalizedId)) {
                // --- Remove country ---
                visitedCountries.delete(normalizedId);
                if (!countryElement.empty()) { // Update SVG map if element exists
                    removeFlagPattern(countryElement, normalizedId); // Remove flag pattern from map
                }
                changed = true;
                console.log(`Removed: ${name}`);
            } else {
                // --- Add country ---
                visitedCountries.add(normalizedId);
                if (!countryElement.empty()) { // Update SVG map if element exists
                    applyFlagPattern(countryElement, normalizedId, resolvedIsoA2); // Apply flag pattern to map
                    countryElement.classed("visit-animate", true);
                    setTimeout(() => countryElement.classed("visit-animate", false), 700);
                }
                changed = true;
                console.log(`Added: ${name}`);
            }

            // If the visited set changed, update UI elements, save state, and flag globe texture update
            if (changed) {
                updateVisitedInfo(); // Update count, list, progress bar, buttons
                saveState(); // Save the new state to localStorage
                globeNeedsTextureUpdate = true; // Signal the globe texture needs regeneration

                 // If globe is currently the active view and initialized, trigger the texture update immediately
                 // Otherwise, the update will happen when switching to the globe view or in the next animation frame.
                 if(activeView === 'globe-view' && globeInitialized) {
                    updateGlobeTexture();
                 }
            }

            // Remove pressed state from map element if it exists (relevant for map clicks)
            if (!countryElement.empty()) {
                countryElement.classed("pressed", false);
            }
            tooltip.style("display", "none"); // Hide tooltip after click
        }


        /** Updates the main title and visited info label based on user name. */
        function updateTitles() {
            if (userName) {
                mainTitleElement.textContent = `Atlasphere of ${userName}`;
                visitedInfoLabelElement.textContent = `Countries Visited by ${userName}:`;
            } else {
                mainTitleElement.textContent = 'Atlasphere';
                visitedInfoLabelElement.textContent = 'Countries Visited:';
            }
            // Update subtitle based on current view and name presence
            updateSubtitle();
        }

        /** Updates the subtitle text based on the active view and user name. */
        function updateSubtitle() {
           // Define base subtitles for each view
           const baseMapSubtitle = 'Interact with the World Map: Hover for name, click to toggle visited status. Use search to jump instantly.';
           const baseGlobeSubtitle = 'Explore the 3D Globe: Drag to rotate, scroll to zoom, click country to toggle visited status. Use search to focus.';
           // Add personalized prefix if name exists
           const namePrefix = userName ? `Welcome, ${userName}! ` : '';

           // Set the subtitle text based on the currently active view
           subtitleElement.textContent = activeView === 'map-view'
                 ? namePrefix + baseMapSubtitle
                 : namePrefix + baseGlobeSubtitle;
        }


        /** Updates the visited count, progress bar, and visited countries list UI elements. */
        function updateVisitedInfo() {
            const count = visitedCountries.size;
            visitedCountElement.textContent = count; // Update the displayed count
            if (visitedCountElement) {
                visitedCountElement.classList.remove('count-pulse');
                void visitedCountElement.offsetWidth;
                visitedCountElement.classList.add('count-pulse');
            }
            const remaining = Math.max(totalCountries - count, 0);
            if (countriesLeftElement) {
                countriesLeftElement.textContent = remaining;
            }
            if (countriesTotalElement) {
                countriesTotalElement.textContent = totalCountries;
            }

            // --- Calculate and update progress bar ---
            const percentage = totalCountries > 0 ? Math.round((count / totalCountries) * 100) : 0;
            progressBar.style.width = `${percentage}%`; // Set the visual width of the bar
            progressBar.textContent = `${percentage}%`; // Display percentage text inside bar
            progressContainer.setAttribute('aria-valuenow', percentage); // Update accessibility attribute
            progressContainer.title = `${count} visited, ${remaining} left of ${totalCountries} (${percentage}%)`; // Update tooltip

            // --- Update the list of visited countries ---
            visitedListDiv.innerHTML = ''; // Clear previous list content
            if (count > 0) {
                visitedListContainer.classList.remove('hidden'); // Show list container if there are visited countries
                const grouped = {}; // Object to group countries by continent

                // Group visited countries by continent using the maps
                visitedCountries.forEach(id => {
                    const meta = countryMetaById[id];
                    const continent = meta?.continent || 'Other Regions'; // Get continent, use fallback if needed
                    const name = meta?.name; // Get country name
                    if (name && name !== 'Unknown') { // Ensure valid name
                        if (!grouped[continent]) {
                            grouped[continent] = []; // Initialize array if first country in this continent
                        }
                        grouped[continent].push(name); // Add country name to the continent's list
                    }
                });

                // Sort continents based on predefined order (continentOrder array)
                const sortedContinents = Object.keys(grouped).sort((a, b) => {
                    const indexA = continentOrder.indexOf(a);
                    const indexB = continentOrder.indexOf(b);
                    // Handle cases where a continent might not be in the predefined order
                    if (indexA === -1 && indexB === -1) return a.localeCompare(b); // Sort unknowns alphabetically
                    if (indexA === -1) return 1; // Put unknowns at the end
                    if (indexB === -1) return -1; // Put unknowns at the end
                    return indexA - indexB; // Sort by predefined order index
                });


                // Create HTML list structure for each continent
                sortedContinents.forEach(continent => {
                    const groupDiv = document.createElement('div');
                    groupDiv.className = 'continent-group';

                    const title = document.createElement('h4');
                    title.className = 'continent-title';
                    title.textContent = continent; // Set continent title
                    groupDiv.appendChild(title);

                    const list = document.createElement('ul');
                    grouped[continent].sort((a, b) => a.localeCompare(b)); // Sort countries alphabetically within the continent
                    grouped[continent].forEach(name => {
                        const li = document.createElement('li');
                        li.textContent = name; // Add country name as list item
                        list.appendChild(li);
                    });
                    groupDiv.appendChild(list);
                    visitedListDiv.appendChild(groupDiv); // Add the continent group (title + list) to the main list div
                });
            } else {
                visitedListContainer.classList.add('hidden'); // Hide list container if no countries visited
            }

            // --- Enable/disable action buttons based on state ---
            downloadSummaryButton.disabled = count === 0; // Enable download only if countries are visited
            // Enable reset if name is entered OR if at least one country is visited
            resetButton.disabled = count === 0 && !isNameEntered;

            // Keep search result badges in sync with visited state
            if (currentSearchQuery) {
                renderSearchResults();
            }

            updatePercentileBanner();
        }

        /** Saves the current state (visited countries set, user name) to localStorage. */
        function saveState() {
            try {
                // Save visited countries array (convert Set to Array for JSON stringification)
                localStorage.setItem('atlasphereVisitedCountries_v3', JSON.stringify(Array.from(visitedCountries)));
                // Save user name if entered, otherwise remove the item from storage
                if (userName) {
                    localStorage.setItem('atlasphereUserName_v3', userName);
                } else {
                     localStorage.removeItem('atlasphereUserName_v3');
                }
                // console.log("State saved."); // Optional log for debugging
            } catch (e) {
                // Handle potential storage errors (e.g., quota exceeded, security restrictions)
                console.error("Could not save state:", e);
                 // Optionally notify user, e.g., via a small non-blocking message
            }
        }

        /** Loads state (visited countries, user name) from localStorage on initialization. */
        function loadState() {
            try {
                // --- Load and parse visited countries ---
                const savedVisited = localStorage.getItem('atlasphereVisitedCountries_v3');
                if (savedVisited) {
                    const parsedVisited = JSON.parse(savedVisited); // Parse the JSON string
                    // Clear existing set before loading saved data
                    visitedCountries.clear();
                    // Add loaded IDs to the Set, but only if they correspond to valid country data loaded earlier
                    parsedVisited.forEach(id => {
                        // Check if the ID exists in our loaded country data maps
                        const normalizedId = normalizeCountryId(id);
                        if (normalizedId && countryMetaById[normalizedId]) {
                             visitedCountries.add(normalizedId); // Add valid ID to the Set
                        } else {
                            // Log if an invalid ID was found in storage (e.g., from older data version)
                            console.warn(`Loaded invalid/unknown country ID from storage: ${id}`);
                        }
                    });
                    console.log(`Loaded ${visitedCountries.size} valid visited countries.`);
                }

                // --- Load user name ---
                const savedName = localStorage.getItem('atlasphereUserName_v3');
                if (savedName) {
                    userName = savedName; // Set the global userName variable
                    isNameEntered = true; // Mark name as entered since it was loaded
                    console.log(`Loaded user name: ${userName}`);
                } else {
                    isNameEntered = false; // No saved name found
                }
            } catch (e) {
                // Handle errors during loading (e.g., corrupted JSON data)
                console.error("Could not load state:", e);
                // Clear potentially corrupted data from localStorage and reset in-memory state
                localStorage.removeItem('atlasphereVisitedCountries_v3');
                localStorage.removeItem('atlasphereUserName_v3');
                visitedCountries.clear(); // Clear in-memory set too
                userName = null;
                isNameEntered = false;
                 // Optionally notify user about the reset
                 // subtitleElement.textContent = 'Could not load previous session. Starting fresh.';
            }
        }

        // === DATA PORTABILITY ===

        function setupDataPortability() {
            if (exportButton) {
                exportButton.addEventListener('click', exportData);
            }

            if (importButton) {
                importButton.addEventListener('click', () => {
                    if (importFileInput) {
                        importFileInput.click();
                    }
                });
            }

            if (importFileInput) {
                importFileInput.addEventListener('change', handleImportFile);
            }
        }

        function exportData() {
            const payload = {
                version: 1,
                exportedAt: new Date().toISOString(),
                userName: userName || '',
                visitedCountries: Array.from(visitedCountries)
            };

            const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
            const link = document.createElement('a');
            const safeName = (userName || 'user').trim().replace(/\s+/g, '_');
            link.href = URL.createObjectURL(blob);
            link.download = `atlasphere_data_${safeName}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(link.href);
        }

        async function handleImportFile(event) {
            const file = event.target.files && event.target.files[0];
            if (!file) return;
            try {
                const text = await file.text();
                const data = JSON.parse(text);
                applyImportedData(data);
            } catch (error) {
                console.error("Import failed:", error);
                alert("Error: Could not import data file.");
            } finally {
                event.target.value = '';
            }
        }

        function applyImportedData(data) {
            if (!data || typeof data !== 'object') {
                alert("Error: Invalid data format.");
                return;
            }

            const importedVisited = Array.isArray(data.visitedCountries) ? data.visitedCountries : [];
            visitedCountries.clear();
            importedVisited.forEach(id => {
                const normalizedId = normalizeCountryId(id);
                if (normalizedId && countryMetaById[normalizedId]) {
                    visitedCountries.add(normalizedId);
                }
            });

            const importedName = typeof data.userName === 'string' ? data.userName.trim() : '';
            if (importedName) {
                userName = importedName;
                isNameEntered = true;
            } else {
                userName = null;
                isNameEntered = false;
            }

            saveState();
            updateTitles();
            updateVisitedInfo();
            applyInitialMapStyles();
            globeNeedsTextureUpdate = true;
            if (activeView === 'globe-view' && globeInitialized) {
                updateGlobeTexture();
            }
            clearSearch();
        }

        // === DOWNLOAD FUNCTIONALITY ===

        function getSummaryTagline() {
            const count = visitedCountries.size;
            if (!totalCountries || count <= 0) {
                return 'Your journey is just beginning.';
            }
            const percentile = estimateTravelPercentile(count, totalCountries);
            const topPercent = Math.max(100 - percentile, 0.01);
            const formattedTop = formatTopPercent(topPercent);
            const lead = count < 3 ? 'Great start' : 'Impressive';
            return `${lead}, you are in the top ${formattedTop}% of travelers on this planet.`;
        }

        function stripIds(node) {
            if (!node) return;
            if (node.removeAttribute) {
                node.removeAttribute('id');
            }
            if (node.querySelectorAll) {
                node.querySelectorAll('[id]').forEach(element => element.removeAttribute('id'));
            }
        }

        function buildSummaryMapClone() {
            const svgNode = mapSvg?.node?.();
            if (!svgNode) return null;
            const clone = svgNode.cloneNode(true);

            const group = clone.querySelector('#map-group');
            if (group) {
                group.removeAttribute('transform');
            }

            const defs = clone.querySelector('defs');
            if (defs) {
                defs.remove();
            }

            clone.querySelectorAll('.country').forEach(path => {
                const id = normalizeCountryId(path.getAttribute('data-country-id'));
                const visited = id ? visitedCountries.has(id) : false;
                const fill = visited ? '#e6c48f' : '#1d2536';
                const stroke = visited ? '#f1d9a8' : '#2b344a';
                const strokeWidth = visited ? 1.05 : 0.65;
                path.setAttribute('style', `fill: ${fill}; stroke: ${stroke}; stroke-width: ${strokeWidth};`);
            });

            stripIds(clone);
            return clone;
        }

        function buildSummaryStatsClone() {
            const statsRow = document.getElementById('stats-row');
            if (!statsRow) return null;
            const clone = statsRow.cloneNode(true);
            stripIds(clone);
            clone.classList.add('summary-export__stats');
            return clone;
        }

        function buildSummaryVisitedListClone() {
            if (!visitedListContainer) return null;
            const clone = visitedListContainer.cloneNode(true);
            clone.classList.remove('hidden');
            stripIds(clone);
            clone.classList.add('summary-export__list');
            return clone;
        }

        function buildSummaryExportElement() {
            const wrapper = document.createElement('div');
            wrapper.className = 'summary-export';

            const header = document.createElement('div');
            header.className = 'summary-export__header';

            const title = document.createElement('div');
            title.className = 'summary-export__title';
            title.textContent = mainTitleElement?.textContent || 'Atlasphere';

            const tagline = document.createElement('div');
            tagline.className = 'summary-export__tagline';
            tagline.textContent = getSummaryTagline();

            header.appendChild(title);
            header.appendChild(tagline);

            const mapFrame = document.createElement('div');
            mapFrame.className = 'summary-export__map';
            const mapClone = buildSummaryMapClone();
            if (mapClone) {
                mapFrame.appendChild(mapClone);
            }

            const footer = document.createElement('div');
            footer.className = 'summary-export__footer';

            const statsClone = buildSummaryStatsClone();
            if (statsClone) {
                footer.appendChild(statsClone);
            }

            const listClone = buildSummaryVisitedListClone();
            if (listClone) {
                footer.appendChild(listClone);
            }

            wrapper.appendChild(header);
            wrapper.appendChild(mapFrame);
            wrapper.appendChild(footer);

            document.body.appendChild(wrapper);
            return wrapper;
        }

        /** Sets up the event listener for the download summary button. */
        function setupDownloadButton() {
            if (!downloadSummaryButton) return; // Ensure button exists

            downloadSummaryButton.addEventListener('click', async () => {
                // Disable button and show generating message during processing
                downloadSummaryButton.disabled = true;
                downloadSummaryButton.textContent = 'Generating...';

                let exportElement = null;
                try {
                    console.log("Generating summary image...");
                    exportElement = buildSummaryExportElement();

                    await new Promise(resolve => requestAnimationFrame(resolve));
                    await new Promise(resolve => setTimeout(resolve, 60));

                    const bgColor = getComputedStyle(document.documentElement).getPropertyValue('--bg-primary').trim() || '#0b0e12';

                    const canvas = await html2canvas(exportElement, {
                        backgroundColor: bgColor,
                        useCORS: true,
                        logging: false,
                        scale: 2
                    });

                    console.log("Summary image generated.");

                    const imageDataUrl = canvas.toDataURL('image/png');
                    const link = document.createElement('a');
                    link.href = imageDataUrl;
                    const filename = `atlasphere_summary_${(userName || 'user').replace(/\s+/g, '_')}.png`;
                    link.download = filename;

                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    console.log("Download initiated.");

                } catch (error) {
                    // Handle errors during image generation or download
                    console.error("Error generating image:", error);
                    alert("Error: Could not generate summary image."); // Use alert for user feedback on critical errors
                } finally {
                    if (exportElement) {
                        exportElement.remove();
                    }
                    // Re-enable the button and restore its text, ensuring correct disabled state
                    downloadSummaryButton.disabled = visitedCountries.size === 0;
                    downloadSummaryButton.textContent = 'Download Summary';
                }
            });
        }

        // === RESET FUNCTIONALITY ===

        /**
         * Resets the application state (visited countries, user name) by clearing
         * localStorage and then refreshing the page.
         */
        function resetApp() {
            // Confirmation dialog to prevent accidental reset
            if (!confirm("Are you sure you want to reset all visited countries and your name? This action cannot be undone.")) {
                console.log("Reset cancelled by user.");
                return; // Stop reset if user clicks 'Cancel'
            }

            console.log("Resetting map data and user name...");

            // Clear relevant items from localStorage - THIS IS THE CRITICAL STEP before reloading.
            localStorage.removeItem('atlasphereVisitedCountries_v3');
            localStorage.removeItem('atlasphereUserName_v3');

            console.log("Local storage cleared. Refreshing page...");

            // Refresh the page to force a reload from the now-cleared localStorage.
            // Add a slight delay to allow console logs to potentially show before the reload happens.
            setTimeout(() => {
                window.location.reload();
            }, 150);
        }

        /** Sets up the event listener for the reset button. */
        function setupResetButton() {
            if (!resetButton) return; // Ensure button exists
            resetButton.addEventListener('click', () => {
                resetApp(); // Call the reset function when the button is clicked
            });
            // Set initial disabled state based on the loaded state (can reset if name entered OR countries selected)
             resetButton.disabled = visitedCountries.size === 0 && !isNameEntered;
        }


        // === RESIZE HANDLING ===

        /** Handles window resize events to adjust map and globe views. */
        function handleResize() {
            // --- Map View Resizing ---
            // SVG map view resizing is largely handled automatically by the `viewBox`
            // and `preserveAspectRatio="xMidYMid meet"` attributes on the SVG element.
            // No specific JavaScript intervention is usually needed unless complex scaling logic is required.

            // --- Globe View Resizing ---
            // If the globe is initialized, update camera aspect ratio and renderer size
            if (globeInitialized && globeContainer && globeRenderer && globeCamera) {
                const width = globeContainer.clientWidth;
                const height = globeContainer.clientHeight;
                // Ensure dimensions are valid (greater than 0) before updating
                if (width > 0 && height > 0) {
                    globeCamera.aspect = width / height; // Update camera aspect ratio to match new container dimensions
                    globeCamera.updateProjectionMatrix(); // Apply the aspect ratio change
                    globeRenderer.setSize(width, height); // Resize the WebGL renderer output canvas
                } else {
                    // Log a warning if the container dimensions are zero, which might indicate a layout issue
                    console.warn("Globe container zero dimensions on resize.");
                }
            }
        }

        // --- Start the application ---
        // Call the main initialization function when the script loads
        initializeApp();

    </script>

</body>
</html>
